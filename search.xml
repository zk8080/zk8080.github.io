<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS事件循环(Event Loop)]]></title>
    <url>%2F2019%2F04%2F11%2FJS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日常开发中，总会出现各种因为同步异步行为导致的问题。最近和同事们讨论React中setState同步异步的问题，在网上看到一些解析和总结，发现自己其实对js的执行机制并不太理解。因此在网上查阅了一些资料，来完善一下自己的知识，本文是自己记录一下对js执行机制的理解。先看一段代码:1234567891011setTimeout(function()&#123; console.log(&apos;a&apos;)&#125;,0)console.log(&apos;b&apos;)setTimeout(function()&#123; console.log(&apos;c&apos;)&#125;,1000)console.log(&apos;d&apos;)setTimeout(function()&#123; console.log(&apos;e&apos;)&#125;,0) 按照js是一门单线程语言，代码是从上到下的顺序执行的，我们会很正常的认为打印的结果是abdec,但是去chrome中验证下，却发现结果并不是这样。 同步和异步原来js中将代码执行分为了同步和异步，当同步代码执行完毕后，才会去执行异步代码。setTimeout、setInterval、callback、Promise等，都属于异步操作。但是具体的执行机制是什么呢？我们可以看下面这张图(出处在文章尾部):从这张图里我们可以知道: js会将任务分为同步任务和异步任务，同步任务进入主线程，异步任务进入Event Table，并且注册回调函数， 回调函数进入Event Queue; 主线程的任务执行完毕，到Event Queue中读取对应的函数，然后进入主线程去执行。以上会重复执行，这就是js的执行机制，也是事件循环(Event Loop)。 知道了这些后，再看上面的代码，我们知道了setTimeout属于异步操作，会进入Event Table,等待主线程任务执行完毕才会去执行。但是setTimeout(function(){},0)是不是会立即呢？答案是不会。因为setTimeout(fn, 0)是指当主线程任务执行完毕后会立即执行，不需要再等待多少秒后再执行，所以我们会看到这段代码的结果是bdaec。 接着我们再看一段代码:12345678910setTimeout(function()&#123; console.log(&apos;a&apos;)&#125;,0)new Promise(function(resolve)&#123; console.log(&apos;b&apos;) resolve()&#125;).then(res =&gt; &#123; console.log(&apos;c&apos;)&#125;)console.log(&apos;d&apos;) 按照我们上面的同步异步的执行机制，我们可以知道这段代码会进行以下操作： 异步代码setTimeout进入Event Table 执行同步代码Promise，打印b Promise.then进入Event Table 执行同步代码，打印d 主线程执行完毕，到Event Queue中读取对应的函数，并放到主线程中执行 按照之前的理解，这个时候应该是先打印a再打印c，但是我们到chrome中验证一下发现结果是先打印c再打印a，这是为什么呢？ 宏任务和微任务查阅了一些文章后，原来js将任务分为了更精细的宏任务(macro-task)和微任务(micro-task): 宏任务：包括整体代码的script、setTimeout、setInterval 微任务：Promise、process.nextTick(暂不了解,后续学习) 宏任务和微任务之间的执行顺序又是什么呢？我们看下面这张图(出处在文章尾部):从这张图里我们可以知道： js将代码分为宏任务和微任务，先进入宏任务中执行 宏任务执行结束后，查看是否有可执行的微任务 有微任务就执行微任务，然后进行下一个宏任务 没有微任务则直接进行下一个宏任务 那么再看我们之前的代码，我们就可以明白为什么结果是先打印c再打印a: 整段代码作为宏任务进入主线程 setTimeout进入Event Table，然后注册回调函数，分发宏任务到Event Queue new Promise立即执行，打印b，then进入Event Table, 注册回调函数，分发微任务到Event Queue console.log()立即执行，打印d 到此第一个宏任务执行完毕，然后查看是否有微任务 有微任务then函数，则执行then函数，打印c 微任务执行完毕，开始执行新的宏任务setTimeout的回调函数,打印a 由此我们就了解到js的执行机制。 结语本文是在看到一些文章后，自己所理解的js执行机制，如有不对，请指出。写完这篇文章后，自己对js的事件循环也有了一个大概的了解，虽然具体的原理和底层的堆、栈等还一知半解，但是后续会努力学习加深自己的理解。 参考文章 这一次，彻底弄懂 JavaScript 执行机制]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用记录]]></title>
    <url>%2F2019%2F03%2F29%2FGit%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[最近工作中使用Git来进行代码管理，由于之前一个人折腾，并不会遇到太多冲突代码的问题，所以遇到冲突的情况，就会导致需要去各种百度查文档才能解决。因此写一篇文章记录自己常用的命令和流程，以及遇到的问题和解决方法。 基础语法初始化仓库初始化仓库有两种方法：第一种是直接在当前目录把所有文件导入到Git中；第二种是从远程服务器克隆一个Git仓库到本地。 git init 执行该命令会在在当前目录中初始化一个Git仓库，创建一个.git的文件夹，这个.git文件夹中包含了所有初始化Git仓库必须的文件，是Git的核心。 git clone [远程服务器仓库地址] [本地目录名] 如果想获取一份已经存在远程服务器上的Git仓库，则执行该命令即可。可在服务器url参数后添加一个本地仓库的名字。 查看文件状态git status执行该命令可以看到当前哪些文件处于什么状态。目前我所知道的有以下几个状态： modified: 文件被修改 new file: 新增的文件 deleted: 文件被删除 renamed: 文件重命名 both modified: 文件有冲突 提交代码到本地仓库在使用查看完文件状态后，如果文件状态有所改变，我们可以将文件提交到本地仓库。git add [option]使用该命令可以将修改的文件放到暂存区，或者追踪新的文件并放到暂存区。option参数可以传.、*、-A、-u、文件夹、文件。 git add .: 会把工作区所有变化提交到暂存区，包括modified和new file状态的，但是不包括deleted的状态。 git add *: 和git add .功能一样，但是不会提交以.开头的文件。 git add -u: 会把工作区已经放到暂存区的文件进行更新(包括modified和deleted)，但是不会提交新增文件(new file)。即只监控已经add的文件。 git add -A: 提交工作区所有变化，git add .和git add -u的合集。 git add 文件夹: 提交当前文件夹所有更改到暂存区。 git add 文件: 提交当前文件到暂存区。 git commit -m &#39;remark&#39;使用该命令可以将暂存区的文件，提交到本地仓库。remark代表本次提交说明。git commit -a -m &#39;remark&#39;使用该命令可以省略git add命令，直接把所有已经追踪过的文件暂存起来提交到本地仓库(是否包含新文件，待验证)。 查看提交历史git log执行该命令后，可以看到根据提交时间排序的所有信息，这些信息包括提交的SHA-1值(commit_id)，作者，提交时间，提交说明等。 取消暂存文件或者文件的修改git rest HEAD [文件名]执行该命令后，可以把已经add的文件取消暂存。git checkout -- [文件名]执行该命令后，可以撤销该文件所有的修改(撤销后无法恢复)。 撤销commit提交git reset --[option] [commit_id]执行该命令后，可以将已经commit的修改进行撤销，根据option的不同，会出现不同的结果： soft: 会将已经commit的修改，撤销到暂存区 mixed: 不会把已经commit的修改，撤销到暂存区 hard: 撤销已经commit的修改，并且不会保留。 拉取远程仓库代码git pull如果本地分支已经跟踪了远程分支，执行该命令后，会拉取远程分支代码并且合并到本地分支。git fetch [远程仓库名]执行该命令后，会拉取远程仓库所有本地没有的数据到本地仓库，但是并不会自动合并和修改当前的分支，需要手动合并到当前分支。(目前还没有使用过，后续使用会再进行深入理解。) 提交当前代码到远程仓库git push [远程仓库] [分支名]使用该命令，会将已经commit到本地仓库的代码提交到远程仓库中。如果本地分支与远程分支关联了，直接git push即可，如果没有，则需要加上远程仓库名和分支名称，例如: git push origin master。 添加远程仓库git remote add [仓库名] [远程仓库地址]如果使用了git init初始化一个Git仓库后，想要把代码提交到远程仓库，可以使用该命令将本地仓库和远程仓库关联起来。如果已经有远程仓库了，也可以使用该命令再新增一个远程仓库，不过在拉取代码的时候需要指定仓库名。 使用分支git branch [option] [分支名] [远程仓库名/远程分支名]执行该命令后，可以查看到当前本地所有分支列表，分支名前带*的是当前所处的分支。目前我所知道的option参数有以下: -a: 展示所有分支，包括本地和远程。 -v: 查看本地每一个分支最后一次提交。 -d: 删除分支。 -D: 强制删除分支。 -vv: 查看本地分支和其所关联的远程分支。 如果git branch后直接写分支名，则是创建一个新分支；如果分支名后加上远程仓库名/远程分支名，则可以创建一个关联到远程分支的本地分支。例如:git branch test origin/test使用该命令后则可以在本地创建一个关联到远程test分支的test分支。使用git branch -u [远程仓库名/远程分支名]可以使当前分支关联到远程分支，如果当前分支已经关联远程分支，那么该操作则会更改当前分支关联的远程分支。git checkout [分支名]执行该命令后，可以切换到对应的分支下。使用git checkout -b [分支名]可以快速创建一个新分支，并且切换到该分支。使用git checkout -b [分支名] [远程仓库名/分支名]可以新建一个关联到远程分支的分支，并且切换到该分支；也可以使用git checkout --track [远程仓库名/分支名],但是创建的分支名会和远程分支相同。git checkout [分支名] [文件目录]在当前分支下执行该命令，会将对应分支名下的文件目录覆盖到当前分支对应的文件目录。git push [远程仓库名] [分支名]执行该命令可以将当前分支代码提交到对应远程分支，如果远程没有对应分支，则会新建一个远程分支并且提交。 储藏git stash执行该命令后，会将当前分支下的所有修改和暂存进行储藏，保存到一个栈上。储藏后的分支是一个干净的目录，可以直接拉取远程代码，并且不会出现任何冲突。git stash list执行该命令后，会列出所有进行过的储藏。stash@{数字}代表储藏的名字。git stash apply [储藏名]执行该命令后，可以将对应储藏名的储藏修改应用到当前分支上，不传储藏名则默认应用最新的储藏。该操作不会删除储藏，如果想要在应用储藏后移除储藏则可以使用git stash drop [储藏名]来移除储藏。git stash pop [储藏名]执行该命令后，会将对应储藏应用到当前分支，并且移除储藏。不传储藏名，则默认应用最新的储藏，并且移除它。 目前工作中的使用流程当前我所使用的提交流程123456789git status // 查看当前分支状态git stash // 储藏当前修改git pull // 拉取远程分支代码git stash pop // 应用上次储藏git status // 查看应用储藏后的状态********* // 解决冲突和合并git add [目录] // 暂存对应目录下的修改git commit -m &apos;remark&apos; // 提交到本地仓库git push // 提交到远程仓库 结束语以上只是我目前所使用过和了解的一些语法和流程，目前只是很浅显的知道如何使用git去管理代码，其中的原理还不知其所以然，后续会抽时间去研究一下做补充，也会把自己遇到的问题和解决方法也记录在这里。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloWorld]]></title>
    <url>%2F2019%2F03%2F26%2FHelloWorld%2F</url>
    <content type="text"><![CDATA[新的开始经历了一些事情，终于狠下心来买了人生的第一台MacBook Pro，也折腾了两三天，把自己的博客又重新搭了起来；希望从今天开始，自己能够坚持记录生活和工作上的一些事！加油！！！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
