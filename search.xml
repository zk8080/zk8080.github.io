<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Antd的Form组件配合Mobx双向数据绑定]]></title>
    <url>%2F2019%2F08%2F09%2FAntd%E7%9A%84Form%E7%BB%84%E4%BB%B6%E9%85%8D%E5%90%88Mobx%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[最近忙于赶项目，一直没有时间去更新博客，今天得空，正好把最近在项目中使用Mobx和Antd中的Form组件进行双向数据绑定的方法记录一下。 为什么需要双向数据绑定？在后台管理系统中，表单是及其重要的，因为我们的增、改、查三个操作都需要用到表单。增加和查询一般是手动填入的，而修改则是需要将已有的数据先反显到表单中，再进行修改。这个反显的过程就需要对表单进行双向数据绑定了。 怎么进行双向数据绑定？在Antd的Form组件中，使用Form.create()包装组件后，该组件的props属性就会多一个form对象，该对象提供了一些api，具体的可以查看Antd的官方文档进行查看，其中getFieldDecorator是该组件提供的双向数据绑定的api。直接上代码来看用法：1234567891011&lt;Form&gt; &lt;Form.Item&gt; &#123;getFieldDecorator(&apos;username&apos;, &#123; rules: [&#123; required: true, message: &apos;Please input your username!&apos; &#125;], &#125;)( &lt;Input placeholder=&quot;Username&quot; /&gt; )&#125; &lt;/Form.Item&gt;&lt;/Form&gt; 用法很简单，将控件对应的key值和配置项传入到getFieldDecorator函数中，然后再使用getFieldDecorator包装控件。这个配置项具体有哪些参数可以去查看官方文档，目前我在项目中用的比较多的就是校验功能，也就是rules配置，使用该参数可以配置校验规则和提示。但是使用getFieldDecorator函数也有antd定制的规则： 经过getFieldDecorator包装的控件，表单控件会自动添加value和onChange，数据同步将被Form接管。 不再需要也不应该用onChange来做同步，但还是可以继续监听onChange等事件。 不能用控件的value、defaultValue等属性来设置表单域的值，默认值可以用getFieldDecorator里的initialValue。 不应该用setState，可以使用this.props.form.setFieldsValue来动态改变表单值。有了这些规则后，说明我们不能去使用value和onChange配合使用进行双向数据绑定了，而是要使用this.props.form.setFieldsValue来设置值，但是这样通过onChange又是及其的繁琐。 使用Mobx数据双向数据绑定在我的项目中，用的状态管理库为Mobx，如何将Mobx中观察的数据传入到Form组件中，我们走了很多弯路，开始我们发现getFieldDecorator函数的配置项中提供了一个initialValue的属性，使用该属性可以将Mobx的数据反显到表单控件中，但是该属性仅是表单控件的初始值，类似于defaultValue的功能，所以只要我们在页面中手动触发了控件的value改变，initialValue就不会再生效了，也就是说反显是ok的，但是如果要操作就会出问题。后面仔细阅读文档后，发现Form.create()函数中提供了mapPropsToFields和onFieldsChange两个api，这两个api配合使用可以将Mobx观察的数据传入到Form组件中，而且组件修改时也能实时传入到Mobx中。具体用法如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 将mobx中观察的数据 转换为mapPropsToFields所需要的结构const objToForm = (obj = &#123;&#125;) =&gt; &#123; const target = &#123;&#125;; for(const [key,value] of Object.entries(obj))&#123; if(typeof value == &apos;object&apos; &amp;&amp; !Array.isArray(value))&#123; target[key] = Form.createFormField(value); &#125;else&#123; target[key] = Form.createFormField(&#123;value&#125;); &#125; &#125; return target;&#125;const onFieldsChange = (props, changedFields) =&gt; &#123; props.setQueryData(&#123;...props.queryData, ...changedFields&#125;);&#125;;const mapPropsToFields = (props) =&gt; &#123; return objToForm(props.queryData);&#125;;@Form.create(&#123; mapPropsToFields, onFieldsChange&#125;)class Index extends Component &#123; constructor(props) &#123; super(props); this.state=&#123;&#125;; &#125; render() &#123; const &#123;getFieldDecorator&#125; = this.props.form; return ( &lt;Form&gt; &lt;Form.Item&gt; &#123;getFieldDecorator(&apos;username&apos;, &#123; rules: [&#123; required: true, message: &apos;Please input your username!&apos; &#125;], &#125;)( &lt;Input placeholder=&quot;Username&quot; /&gt; )&#125; &lt;/Form.Item&gt; &lt;/Form&gt; ); &#125;&#125; 主要是要将mapPropsToFields方法中接受的Mobx数据转换为Form组件可接受的数据结构，并且使用Form.createFormField包装数据，而onFieldsChange方法则是将当前改变的控件数据再提供给Mobx去使用，这样就形成了一个双向数据绑定的效果。但是需要注意的是，onFieldsChange函数提供的数据并不是简单的key: value这种直接可以使用的键值对了，如果需要拿到表单数据进行接口交互的话，需要再将Mobx中的数据进行转换一下，或者直接使用this.props.form.validateFields方法拿到校验通过的所有表单数据来进行交互。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Antd</tag>
        <tag>Mobx</tag>
        <tag>Form</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React生命周期执行顺序详解]]></title>
    <url>%2F2019%2F05%2F15%2FReact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不管是使用React还是Vue，生命周期都是我们必须掌握的。最近在面试的时候，很多人搞不清楚React的生命周期的执行顺序，所以写一篇文章来解析一下React的生命周期函数的执行顺序。本文只介绍常用的生命周期函数的执行顺序，所以有部分不常用的执行顺序可以去看React官方文档。我们先看一张官方文档中的生命周期图谱（v16.4）：根据这个图，我们可以分三个阶段来解析React的生命周期执行顺序： 组件初始化创建(Mounting)阶段此阶段的顺序为：constructor -&gt; componentWillMount -&gt; render -&gt; ComponentDidMount。由于React新的版本中将一些生命周期函数标记为‘过时’，所以在图谱中我们没有看到componentWillMount，但是现在依然可以使用这个生命周期函数。我们可以看下面这行代码来检验这个阶段的执行顺序：1234567891011121314151617181920class Index extends Component &#123; constructor(props) &#123; super(props); console.log(&apos;constructor&apos;); &#125; componentWillMount() &#123; console.log(&apos;componentWillMount&apos;); &#125; componentDidMount() &#123; console.log(&apos;componentDidMount&apos;); &#125; render() &#123; console.log(&apos;render&apos;); return ( &lt;div&gt; render &lt;/div&gt; ) &#125;&#125; 打开chrome浏览器检验一下结果：这个顺序没有什么疑问，但是如果是嵌套组件呢？父子组件之前的顺序是什么样的呢？ 嵌套组件初始化创建阶段我们再看一段代码：1234567891011121314151617181920212223242526272829303132333435363738394041class Parent extends Component &#123; constructor(props) &#123; super(props); console.log(&apos;constructor---Parent&apos;); &#125; componentWillMount() &#123; console.log(&apos;componentWillMount---Parent&apos;); &#125; componentDidMount() &#123; console.log(&apos;componentDidMount---Parent&apos;); &#125; render() &#123; console.log(&apos;render---Parent&apos;); return ( &lt;div&gt; &lt;Child /&gt; &lt;/div&gt; ) &#125;&#125;class Child extends Component &#123; constructor(props) &#123; super(props) console.log(&apos;constructor---Child&apos;) &#125; componentWillMount() &#123; console.log(&apos;componentWillMount---Child&apos;) &#125; componentDidMount() &#123; console.log(&apos;componentDidMount---Child&apos;) &#125; render() &#123; console.log(&apos;render---Child&apos;) return ( &lt;div&gt; Child &lt;/div&gt; ) &#125;&#125; 这是一个最普通的嵌套组件，我们在chrome中检验一下结果：我们可以看到嵌套组件的执行顺序为： 父组件：constructor -&gt; componentWillMount -&gt; render； 在父组件render的时候开始初始化创建子组件； 子组件：constructor -&gt; componentWillMount -&gt; render -&gt; componentDidMount； 最后子组件执行完毕后，再回到父组件执行componentDidMount。 组件更新(Updating)阶段如果要触发组件更新有两种情况（不考虑Redux、Mobx等数据流管理工具）： setState更新state后触发组件自身更新 父组件更新后触发子组件的更新 第一种情况是当前组件内部的更新，第二种情况是由于父组件更新导致子组件的更新。这两种情况都会触发更新，但是有部分生命周期函数的执行不一样，我们先看第一种情况： setState触发的组件自身更新先看下面一段代码：1234567891011121314151617181920212223242526272829303132class Index extends Component &#123; constructor(props) &#123; super(props); console.log(&apos;constructor&apos;); this.state=&#123; count: 0 &#125; &#125; componentWillMount() &#123; console.log(&apos;componentWillMount&apos;); &#125; componentDidMount() &#123; console.log(&apos;componentDidMount&apos;); this.setState(&#123; count: 1 &#125;) &#125; componentWillUpdate()&#123; console.log(&apos;componentWillUpdate&apos;) &#125; componentDidUpdate()&#123; console.log(&apos;componentDidUpdate&apos;); &#125; render() &#123; console.log(&apos;render&apos;); return ( &lt;div&gt; Index &lt;/div&gt; ) &#125;&#125; 接着在chrome中验证一下结果：通过这个结果我们可以得到以下的结论：更新state后的组件自身更新生命周期执行顺序：componentWillUpdate -&gt; render -&gt; componentDidUpdate 父组件更新触发的子组件更新这种情况是在嵌套组件中，直接上代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Parent extends Component &#123; constructor(props) &#123; super(props); console.log(&apos;constructor---Parent&apos;); this.state=&#123; count: 0 &#125; &#125; componentWillMount() &#123; console.log(&apos;componentWillMount---Parent&apos;); &#125; componentDidMount() &#123; console.log(&apos;componentDidMount---Parent&apos;); this.setState(&#123; count: 1 &#125;) &#125; componentWillUpdate()&#123; console.log(&apos;componentWillUpdate---Parent&apos;) &#125; componentWillReceiveProps(nextProps)&#123; console.log(&apos;componentWillReceiveProps---Parent&apos;) &#125; componentDidUpdate()&#123; console.log(&apos;componentDidUpdate---Parent&apos;); &#125; render() &#123; console.log(&apos;render---Parent&apos;); return ( &lt;div&gt; &lt;Child /&gt; &lt;/div&gt; ) &#125;&#125;class Child extends Component &#123; constructor(props) &#123; super(props) console.log(&apos;constructor---Child&apos;) this.state = &#123;&#125; &#125; componentWillMount() &#123; console.log(&apos;componentWillMount---Child&apos;) &#125; componentDidMount() &#123; console.log(&apos;componentDidMount---Child&apos;) &#125; componentWillReceiveProps(nextProps)&#123; console.log(&apos;componentWillReceiveProps---Child&apos;) &#125; componentWillUpdate(nextProps, nextState) &#123; console.log(&apos;componentWillUpdate---Child&apos;) &#125; componentDidUpdate(prevProps, prevState) &#123; console.log(&apos;componentDidUpdate---Child&apos;) &#125; render() &#123; console.log(&apos;render---Child&apos;) return ( &lt;div&gt; Child &lt;/div&gt; ) &#125;&#125; 在chrome中验证一下结果：从这个结果中我们可以看到，只有子组件的componentWillReceiveProps方法执行了，我们可以得到以下结论： 父组件执行更新：componentWillUpdate -&gt; render 父组件render后开始更新子组件 子组件执行更新：componentWillReceiveProps -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate 子组件更新完毕后，父组件执行componentDidUpdate，结束更新。 组件卸载(Unmounting)阶段在这个阶段，组件只会执行一个生命周期函数：componentWillUnmount，在这个函数中，我们可以做一些初始化数据的操作。防止组件下次渲染的时候保留了上次的数据。同上面两个阶段，这个阶段，也会出现在嵌套组件中，但是却和之前的执行顺序不太一样： 父组件执行componentWillUnmount 子组件执行componentWillUnmount 结语通过上面的解析，我们可以清晰的知道组件的生命周期执行顺序了： 初始化创建组件阶段： 父组件：constructor -&gt; componentWillMount -&gt; render -&gt; 子组件：constructor -&gt; componentWillMount -&gt; render -&gt; componentDidMount -&gt; 父组件：componentDidMount 更新阶段： 父组件：componentWillUpdate -&gt; render -&gt; 子组件：componentWillReceiveProps -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate -&gt; 父组件：componentDidUpdate 卸载阶段： 父组件：componentWillUnmount 子组件：componentWillUnmount 通过这些代码的检验，得到了以上的结论，当然这些生命周期函数只是常用的，还有一些不常用的大家可以参考一下官网文档。其中有一个shouldComponentUpdate函数是React控制组件更新进行优化的一个生命周期函数，大家可以了解一下。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setState同步异步问题]]></title>
    <url>%2F2019%2F05%2F04%2FsetState%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在React开发中，setState一般都会被认为是异步的。但是最近在掘金上看到一篇文章 你真的理解setState吗？ ，看完后发现setState并不是想象中的异步那么简单。 setState是异步的吗？在React官方文档中，有这样一段话： setState()不总是立刻更新组件。其可能是成批处理或推迟更新。这使得在调用setState()后立刻读取this.state变成一个潜在陷阱。代替地，使用componentDidUpdate或一个setState回调（setState(updater, callback)），当中的每个方法都会保证在更新被应用之后触发。 读完这段话，我们本能的认为setState就是异步的，因为连官方都推荐我们在componentDidUpdate生命周期和setState的callback中去读取this.state。接下来我们用代码去检验一下setState的同步异步： 生命周期中的setState123456789101112131415161718192021222324252627class Index extends Component &#123; constructor(props) &#123; super(props); this.state=&#123; count: 0 &#125; &#125; componentDidMount() &#123; this.setState(&#123; count: 1 &#125;) console.log( this.state.count ) &#125; componentDidUpdate()&#123; console.log(this.state.count) &#125; render() &#123; return ( &lt;div&gt; 测试 &lt;/div&gt; ) &#125;&#125; 在上面这个例子中，我们在componentDidMount中使用setState去更新了count，然后立马打印了一下count；接着在componentDidUpdate中我们也打印了一下count,然后我们在chrome中查看一下控制台，输出为：0 1。这个结果我们并不意外，在开发中这种代码是我们经常遇到，这也说明在生命周期中setState是异步的。 合成事件中的setState123456789101112131415161718192021222324252627class Index extends Component &#123; constructor(props) &#123; super(props); this.state=&#123; count: 0 &#125; &#125; onClick = () =&gt; &#123; this.setState(&#123; count: 1 &#125;) console.log(this.state.count) &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.onClick&#125; &gt; 测试 &lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 看一下这个例子中，我们在onClick事件中使用setState去更新count，接着立马打印了count；我们到chrome中去验证一下，发现打印的还是0，这说明在合成事件中setState也是异步的。 setTimeout中的setState12345678910111213141516171819202122232425class Index extends Component &#123; constructor(props) &#123; super(props); this.state=&#123; count: 0 &#125; &#125; componentDidMount() &#123; setTimeout(() =&gt; &#123; this.setState(&#123; count: 1 &#125;) console.log(this.state.count) &#125;, 0) &#125; render() &#123; return ( &lt;div&gt; 测试 &lt;/div&gt; ) &#125;&#125; 在这个例子中，我们在componentDidMount中定义了一个setTimeout，并且在回调函数中使用setState更新count，然后打印了count；我们在chrome中验证一下，发现控制台中输出的是：1。这个和前面的结果不同，count被实时读取到了，也说明在setTimeout中setState是同步的。 原生事件中的setState1234567891011121314151617181920212223242526272829class Index extends Component &#123; constructor(props) &#123; super(props); this.state=&#123; count: 0 &#125; &#125; componentDidMount() &#123; document.querySelector(&apos;button&apos;).addEventListener(&apos;click&apos;, this.onClick, false) &#125; onClick = () =&gt; &#123; this.setState(&#123; count: 1 &#125;) console.log(this.state.count) &#125; render() &#123; return ( &lt;div&gt; &lt;button&gt; 测试 &lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 在上面的例子中，我们给button按钮使用原生addEventListener的方式，绑定了click事件，并在click事件中使用setState去更新count，然后立马打印了count，接下来我们在chrome中验证一下，发现控制台中输出的是：1。这个结果和setTimeout中setState的结果一致，说明在原生事件中setState也是同步的。 结论通过上面的例子，我们可以得到一下结论： 在生命周期函数中，setState是异步的； 在合成事件中，setState是异步的； 在异步操作中，setState是同步的； 在原生事件中，setState是同步的。 目前得到了这些结论，但是我们并不清楚其中的原理是什么，我查阅了一些资料，发现自己还是不能理解其中奥妙，所以就不在此误导大家，但是自己会努力学习理解这个问题。不过大家可以参考下面文章去发现更深层次的原理： 你真的理解setState吗？]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS事件循环(Event Loop)]]></title>
    <url>%2F2019%2F04%2F11%2FJS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日常开发中，总会出现各种因为同步异步行为导致的问题。最近和同事们讨论React中setState同步异步的问题，在网上看到一些解析和总结，发现自己其实对js的执行机制并不太理解。因此在网上查阅了一些资料，来完善一下自己的知识，本文是自己记录一下对js执行机制的理解。先看一段代码:1234567891011setTimeout(function()&#123; console.log(&apos;a&apos;)&#125;,0)console.log(&apos;b&apos;)setTimeout(function()&#123; console.log(&apos;c&apos;)&#125;,1000)console.log(&apos;d&apos;)setTimeout(function()&#123; console.log(&apos;e&apos;)&#125;,0) 按照js是一门单线程语言，代码是从上到下的顺序执行的，我们会很正常的认为打印的结果是abdec,但是去chrome中验证下，却发现结果并不是这样。 同步和异步原来js中将代码执行分为了同步和异步，当同步代码执行完毕后，才会去执行异步代码。setTimeout、setInterval、callback、Promise等，都属于异步操作。但是具体的执行机制是什么呢？我们可以看下面这张图(出处在文章尾部):从这张图里我们可以知道: js会将任务分为同步任务和异步任务，同步任务进入主线程，异步任务进入Event Table，并且注册回调函数， 回调函数进入Event Queue; 主线程的任务执行完毕，到Event Queue中读取对应的函数，然后进入主线程去执行。以上会重复执行，这就是js的执行机制，也是事件循环(Event Loop)。 知道了这些后，再看上面的代码，我们知道了setTimeout属于异步操作，会进入Event Table,等待主线程任务执行完毕才会去执行。但是setTimeout(function(){},0)是不是会立即呢？答案是不会。因为setTimeout(fn, 0)是指当主线程任务执行完毕后会立即执行，不需要再等待多少秒后再执行，所以我们会看到这段代码的结果是bdaec。 接着我们再看一段代码:12345678910setTimeout(function()&#123; console.log(&apos;a&apos;)&#125;,0)new Promise(function(resolve)&#123; console.log(&apos;b&apos;) resolve()&#125;).then(res =&gt; &#123; console.log(&apos;c&apos;)&#125;)console.log(&apos;d&apos;) 按照我们上面的同步异步的执行机制，我们可以知道这段代码会进行以下操作： 异步代码setTimeout进入Event Table 执行同步代码Promise，打印b Promise.then进入Event Table 执行同步代码，打印d 主线程执行完毕，到Event Queue中读取对应的函数，并放到主线程中执行 按照之前的理解，这个时候应该是先打印a再打印c，但是我们到chrome中验证一下发现结果是先打印c再打印a，这是为什么呢？ 宏任务和微任务查阅了一些文章后，原来js将任务分为了更精细的宏任务(macro-task)和微任务(micro-task): 宏任务：包括整体代码的script、setTimeout、setInterval 微任务：Promise、process.nextTick(暂不了解,后续学习) 宏任务和微任务之间的执行顺序又是什么呢？我们看下面这张图(出处在文章尾部):从这张图里我们可以知道： js将代码分为宏任务和微任务，先进入宏任务中执行 宏任务执行结束后，查看是否有可执行的微任务 有微任务就执行微任务，然后进行下一个宏任务 没有微任务则直接进行下一个宏任务 那么再看我们之前的代码，我们就可以明白为什么结果是先打印c再打印a: 整段代码作为宏任务进入主线程 setTimeout进入Event Table，然后注册回调函数，分发宏任务到Event Queue new Promise立即执行，打印b，then进入Event Table, 注册回调函数，分发微任务到Event Queue console.log()立即执行，打印d 到此第一个宏任务执行完毕，然后查看是否有微任务 有微任务then函数，则执行then函数，打印c 微任务执行完毕，开始执行新的宏任务setTimeout的回调函数,打印a 由此我们就了解到js的执行机制。 结语本文是在看到一些文章后，自己所理解的js执行机制，如有不对，请指出。写完这篇文章后，自己对js的事件循环也有了一个大概的了解，虽然具体的原理和底层的堆、栈等还一知半解，但是后续会努力学习加深自己的理解。 参考文章 这一次，彻底弄懂 JavaScript 执行机制]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用记录]]></title>
    <url>%2F2019%2F03%2F29%2FGit%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[最近工作中使用Git来进行代码管理，由于之前一个人折腾，并不会遇到太多冲突代码的问题，所以遇到冲突的情况，就会导致需要去各种百度查文档才能解决。因此写一篇文章记录自己常用的命令和流程，以及遇到的问题和解决方法。 基础语法设置用户名和邮箱git config --global user.name &#39;用户名&#39;git config --global user.email &#39;用户邮箱&#39; 初始化仓库初始化仓库有两种方法：第一种是直接在当前目录把所有文件导入到Git中；第二种是从远程服务器克隆一个Git仓库到本地。 git init 执行该命令会在在当前目录中初始化一个Git仓库，创建一个.git的文件夹，这个.git文件夹中包含了所有初始化Git仓库必须的文件，是Git的核心。 git clone [远程服务器仓库地址] [本地目录名] 如果想获取一份已经存在远程服务器上的Git仓库，则执行该命令即可。可在服务器url参数后添加一个本地仓库的名字。 查看文件状态git status执行该命令可以看到当前哪些文件处于什么状态。目前我所知道的有以下几个状态： modified: 文件被修改 new file: 新增的文件 deleted: 文件被删除 renamed: 文件重命名 both modified: 文件有冲突 提交代码到本地仓库在使用查看完文件状态后，如果文件状态有所改变，我们可以将文件提交到本地仓库。git add [option]使用该命令可以将修改的文件放到暂存区，或者追踪新的文件并放到暂存区。option参数可以传.、*、-A、-u、文件夹、文件。 git add .: 会把工作区所有变化提交到暂存区，包括modified和new file状态的，但是不包括deleted的状态。 git add *: 和git add .功能一样，但是不会提交以.开头的文件。 git add -u: 会把工作区已经放到暂存区的文件进行更新(包括modified和deleted)，但是不会提交新增文件(new file)。即只监控已经add的文件。 git add -A: 提交工作区所有变化，git add .和git add -u的合集。 git add 文件夹: 提交当前文件夹所有更改到暂存区。 git add 文件: 提交当前文件到暂存区。 git commit -m &#39;remark&#39;使用该命令可以将暂存区的文件，提交到本地仓库。remark代表本次提交说明。git commit -a -m &#39;remark&#39;使用该命令可以省略git add命令，直接把所有已经追踪过的文件暂存起来提交到本地仓库(是否包含新文件，待验证)。 查看提交历史git log执行该命令后，可以看到根据提交时间排序的所有信息，这些信息包括提交的SHA-1值(commit_id)，作者，提交时间，提交说明等。 取消暂存文件或者文件的修改git rest HEAD [文件名]执行该命令后，可以把已经add的文件取消暂存。git checkout -- [文件名]执行该命令后，可以撤销该文件所有的修改(撤销后无法恢复)。 撤销commit提交git reset --[option] [commit_id]执行该命令后，可以将已经commit的修改进行撤销，根据option的不同，会出现不同的结果： soft: 会将已经commit的修改，撤销到暂存区 mixed: 不会把已经commit的修改，撤销到暂存区 hard: 撤销已经commit的修改，并且不会保留。 拉取远程仓库代码git pull如果本地分支已经跟踪了远程分支，执行该命令后，会拉取远程分支代码并且合并到本地分支。git fetch [远程仓库名]执行该命令后，会拉取远程仓库所有本地没有的数据到本地仓库，但是并不会自动合并和修改当前的分支，需要手动合并到当前分支。(目前还没有使用过，后续使用会再进行深入理解。) 提交当前代码到远程仓库git push [远程仓库] [分支名]使用该命令，会将已经commit到本地仓库的代码提交到远程仓库中。如果本地分支与远程分支关联了，直接git push即可，如果没有，则需要加上远程仓库名和分支名称，例如: git push origin master。 添加远程仓库git remote add [仓库名] [远程仓库地址]如果使用了git init初始化一个Git仓库后，想要把代码提交到远程仓库，可以使用该命令将本地仓库和远程仓库关联起来。如果已经有远程仓库了，也可以使用该命令再新增一个远程仓库，不过在拉取代码的时候需要指定仓库名。 使用分支git branch [option] [分支名] [远程仓库名/远程分支名]执行该命令后，可以查看到当前本地所有分支列表，分支名前带*的是当前所处的分支。目前我所知道的option参数有以下: -a: 展示所有分支，包括本地和远程。 -v: 查看本地每一个分支最后一次提交。 -d: 删除分支。 -D: 强制删除分支。 -vv: 查看本地分支和其所关联的远程分支。 如果git branch后直接写分支名，则是创建一个新分支；如果分支名后加上远程仓库名/远程分支名，则可以创建一个关联到远程分支的本地分支。例如:git branch test origin/test使用该命令后则可以在本地创建一个关联到远程test分支的test分支。使用git branch -u [远程仓库名/远程分支名]可以使当前分支关联到远程分支，如果当前分支已经关联远程分支，那么该操作则会更改当前分支关联的远程分支。git checkout [分支名]执行该命令后，可以切换到对应的分支下。使用git checkout -b [分支名]可以快速创建一个新分支，并且切换到该分支。使用git checkout -b [分支名] [远程仓库名/分支名]可以新建一个关联到远程分支的分支，并且切换到该分支；也可以使用git checkout --track [远程仓库名/分支名],但是创建的分支名会和远程分支相同。git checkout [分支名] [文件目录]在当前分支下执行该命令，会将对应分支名下的文件目录覆盖到当前分支对应的文件目录。git push [远程仓库名] [分支名]执行该命令可以将当前分支代码提交到对应远程分支，如果远程没有对应分支，则会新建一个远程分支并且提交。 储藏git stash执行该命令后，会将当前分支下的所有修改和暂存进行储藏，保存到一个栈上。储藏后的分支是一个干净的目录，可以直接拉取远程代码，并且不会出现任何冲突。git stash list执行该命令后，会列出所有进行过的储藏。stash@{数字}代表储藏的名字。git stash apply [储藏名]执行该命令后，可以将对应储藏名的储藏修改应用到当前分支上，不传储藏名则默认应用最新的储藏。该操作不会删除储藏，如果想要在应用储藏后移除储藏则可以使用git stash drop [储藏名]来移除储藏。git stash pop [储藏名]执行该命令后，会将对应储藏应用到当前分支，并且移除储藏。不传储藏名，则默认应用最新的储藏，并且移除它。 删除没有被追踪的文件git clean [option]执行该命令后，会将没有add的文件和文件夹删除，具体option参数如下: -n：会展示哪些文件要被删除，但是不会去做删除操作，只是用来提示 -f：删除当前目录下没有被追踪过的文件，不会删除.gitignore文件里面指定的文件 -f ：删除对应路径下的文件 -df：删除当前目录下没有被追踪过的文件和文件夹 -xf：删除当前目录下所有没有追踪过的文件. 不管他是否是.gitignore文件里面指定的文件夹和文件 目前工作中的使用流程当前我所使用的提交流程123456789git status // 查看当前分支状态git stash // 储藏当前修改git pull // 拉取远程分支代码git stash pop // 应用上次储藏git status // 查看应用储藏后的状态********* // 解决冲突和合并git add [目录] // 暂存对应目录下的修改git commit -m &apos;remark&apos; // 提交到本地仓库git push // 提交到远程仓库 结束语以上只是我目前所使用过和了解的一些语法和流程，目前只是很浅显的知道如何使用git去管理代码，其中的原理还不知其所以然，后续会抽时间去研究一下做补充，也会把自己遇到的问题和解决方法也记录在这里。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloWorld]]></title>
    <url>%2F2019%2F03%2F26%2FHelloWorld%2F</url>
    <content type="text"><![CDATA[新的开始经历了一些事情，终于狠下心来买了人生的第一台MacBook Pro，也折腾了两三天，把自己的博客又重新搭了起来；希望从今天开始，自己能够坚持记录生活和工作上的一些事！加油！！！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
