<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[实现一个获取上一轮props和state的自定义Hook]]></title>
    <url>%2F2020%2F04%2F17%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%8E%B7%E5%8F%96%E4%B8%8A%E4%B8%80%E8%BD%AEprops%E5%92%8Cstate%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89Hook%2F</url>
    <content type="text"><![CDATA[最近在项目中使用了React Hooks，刚上手感觉很好用，不用在写class组件中那么多的生命周期模板语法，尤其是一些需要在componentDidMount和componentDidUpdate中进行的副作用操作，可以直接使用useEffect去替代。写完感觉代码清爽很多，也更乐意去使用React Hooks了。当然，在不熟练的和不去深入了解的情况下会出现很多意想不到的问题。本文是我在将Class组件转换成Hooks的过程中，发现需要在组件中获取上一轮的props和state，但是内置的Hooks Api中并没有提供这个方法，在文档中找到一个可以自定义的Hooks，在此记录下。直接上代码：12345678const usePrevious = (preValue) =&gt; &#123; const ref = useRef(); useEffect(() =&gt; &#123; ref.current = preValue; &#125;, [preValue]) return ref.current;&#125; 如果不太能理解这段代码为什么可以取到上一次的值，那么可以把这段代码放在我们的业务代码中去看一下：1234567891011function Counter() &#123; const [count, setCount] = useState(0); const prevCountRef = useRef(); useEffect(() =&gt; &#123; prevCountRef.current = count; &#125;); const prevCount = prevCountRef.current; return &lt;h1&gt;Now: &#123;count&#125;, before: &#123;prevCount&#125;&lt;/h1&gt;;&#125; 另外还要记住两点： useRef会保持引用不变，ref.current的值改变并不会引起组件重新渲染 React Hooks中函数式组件的生命周期中，useEffect是在jsx渲染之后执行的 只要记住这两点，再结合上面这段代码，你就会知道为什么我们可以获取到上一次的props和state了。 参考文章 React官方文档useRef为什么可以用来封装成usePrevious?(知乎)一篇文章，带你学会useRef、useCallback、useMemo(知乎)]]></content>
      <tags>
        <tag>React</tag>
        <tag>React Hooks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析双向数据绑定原理]]></title>
    <url>%2F2019%2F12%2F12%2F%E6%B5%85%E6%9E%90%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[之前一直对双向数据绑定一知半解，只知道是通过Object.definedProperty进行数据劫持，配合发布-订阅模式进行视图更新。最近看了一些文章，自己也加深了对双向数据绑定的理解，所以来记录一下。 双向数据绑定实现思路我们要实现双向数据绑定可以参考下图思路： 利用Proxy或Object.defineProperty生成的Observer针对对象/对象的属性进行”劫持”,在属性发生变化后通知订阅者 解析器Compile解析模板中的Directive(指令)，收集指令所依赖的方法和数据,等待数据变化然后进行渲染 Watcher属于Observer和Compile桥梁,它将接收到的Observer产生的数据变化,并根据Compile提供的指令进行视图渲染,使得数据变化促使视图变化 数据劫持数据劫持简单来说就是对对象/对象属性进行拦截，当属性发生改变时，我们可以获取改变进行一些操作。数据劫持目前有两种方法，Object.definedProperty和Proxy。本文我们主要利用Object.definedProperty来实现双向数据绑定。首先我们利用数据劫持实现一个Observer监听者，监听数据变更，进行依赖收集和派发更新：1234567891011121314151617181920212223242526272829303132333435363738394041/*** @description: 监听者* @param &#123;type&#125; data: 需要监听的数据* @return: */function Observer(data) &#123; this.data = data; this.walk(data);&#125; Observer.prototype.walk = function (data) &#123; // 循环遍历属性，进行拦截操作 Object.keys(data).forEach(key =&gt; defineReactive(data, key, data[key]))&#125;function defineReactive(data, key, value) &#123; // 对当前监听的值进行递归监听， 如果是复杂类型则继续监听，因为defineProperty只能监听一层属性 let childObser = observer(value); Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function () &#123; // 在这里进行依赖收集 return value; &#125;, set: function (newValue) &#123; if(value !== newValue)&#123; value = newValue; childObser = observer(value); // 在这里派发更新 &#125; &#125; &#125;)&#125;function observer(data) &#123; // 如果传进来的数据不存在或者不是复杂类型 则直接返回即可 if(!data || typeof data !== &apos;object&apos;)&#123; return data; &#125; return new Observer(data);&#125; 依赖收集监听者实现后，我们来实现依赖收集容器，也就是订阅发布中心(Dep)。它主要用于收集订阅者，然后在数据改变时，进行消息发布，执行订阅者的更新方法。123456789101112131415161718192021222324252627282930/*** @description: 订阅发布中心* @param &#123;type&#125; * @return: */let uid = 0;function Dep() &#123; // 设置id,用于区分新Watcher和只改变属性值后新产生的Watcher this.id = uid ++; // 用来存储订阅者的数组 this.subs = [];&#125;// 静态属性，指向当前的订阅者WatcherDep.target = null;// 收集依赖， 触发订阅者Watcher中的addDep，将自身穿进去Dep.prototype.depend = function () &#123; Dep.target.addDep(this);&#125;// 添加订阅者Dep.prototype.addSub = function (sub) &#123; this.subs.push(sub)&#125;// 派发更新，触发订阅者Watcher的update方法Dep.prototype.notify = function () &#123; this.subs.forEach(sub =&gt; sub.update())&#125; 订阅发布中心很简单，需要注意的是target这个静态属性，这个属性指向订阅者Watcher，是Watcher和Dep进行关联的地方，也保证了同一时间只有一个Watcher。实现完发布订阅中心后，我们将监听者中的发布订阅的代码补充以下：123456789101112131415161718192021222324function defineReactive(data, key, value) &#123; const dep = new Dep(); // 对当前监听的值进行递归监听， 如果是复杂类型则继续监听，因为defineProperty只能监听一层属性 let childObser = observer(value); Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function () &#123; // 在这里进行依赖收集 if(Dep.target)&#123; dep.depend(); &#125; return value; &#125;, set: function (newValue) &#123; if(value !== newValue)&#123; value = newValue; childObser = observer(newValue); // 在这里派发更新 dep.notify(); &#125; &#125; &#125;)&#125; 接下来我们实现订阅者： 订阅者订阅者Watcher主要是用来将观察的数据，触发监听者Observer中的get函数，进行依赖收集，并且将自己传递给订阅发布中心Dep，在Dep派发更新时，触发自己的update函数，更新视图。123456789101112131415161718192021222324252627282930313233343536373839404142/*** @description: 订阅者* @param &#123;type&#125; vm 被订阅的数据所在实例* @param &#123;type&#125; key 被订阅的数据属性* @param &#123;type&#125; callback 数据更新后的回调函数*/function Watcher(vm, key, callback ) &#123; this.depId = &#123;&#125;; // 存储订阅者id，防止重复订阅 this.vm = vm; this.key = key; this.callback = callback; this.val = this.get(); // 获取被观察的数据，进行依赖收集&#125;// 依赖收集 将自己添加到发布订阅中心中的订阅者数组中Watcher.prototype.addDep = function (dep) &#123; if( !this.depId.hasOwnProperty(dep.id) )&#123; dep.addSub(this); this.depId[dep.id] = dep; &#125;&#125;// 用于数据更新时，发布时执行的回调函数Watcher.prototype.update = function () &#123; this.run();&#125;Watcher.prototype.run = function () &#123; const newVal = this.get(); if(this.val !== newVal)&#123; this.val = newVal; this.callback(newVal); &#125;&#125;Watcher.prototype.get = function () &#123; // 将Dep的target指向当前订阅者，用于依赖收集 Dep.target = this; const val = this.vm.data[this.key]; //获取订阅的属性值，触发依赖收集 // 依赖收集完成后 清除当前订阅者 Dep.target = null; return val;&#125; 测试我们已经把双向数据绑定所需要的监听者Observer、订阅发布中心Dep、订阅者Watcher都实现了。还差一个解析器Compile去解析模板中的指令来与订阅者和数据进行关联，进行依赖收集，收到数据更新后，进行视图更新，在这我们就不做具体的实现了，大家可以去看这篇文章，这篇文章对双向数据绑定做了详细的介绍。接下来我们测试以下我们的双向数据绑定：123456789101112131415161718function Vue(data, el, key) &#123; this.data = data; observer(data); el.innerHTML = this.data[key]; new Watcher(this, key, function (value) &#123; el.innerHTML = value; &#125;)&#125;const p = document.getElementById(&apos;p&apos;);const input = document.getElementById(&apos;input&apos;);const testVue = new Vue(&#123; name: &apos;&apos;&#125;, p, &apos;name&apos;);input.addEventListener(&apos;keyup&apos;, function (e) &#123; testVue.data.name = e.target.value;&#125;) 可以看到我们在input输入的时候，p标签内也会做实时更新。到此我们的双向数据绑定也就搞定了，不过具体详细的还是建议大家去读一下大佬们的文章。 参考文章 剖析Vue原理&amp;实现双向绑定MVVM面试官: 实现双向绑定Proxy比defineproperty优劣如何?通俗易懂了解Vue双向绑定原理及实现]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现遵循Promise/A+规范的自定义Promise对象]]></title>
    <url>%2F2019%2F11%2F14%2F%E5%AE%9E%E7%8E%B0%E9%81%B5%E5%BE%AAPromise-A-%E8%A7%84%E8%8C%83%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89Promise%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[最近几天看了一些关于promise的文章，自己也根据理解总结一下，怎么手写一个符合Promise/A+规范的Promise。 什么是Promise阮一峰老师的《ECMAScript 6 入门》中是这样解释的： Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 什么是Promise/A+规范 一个开放的，可实现的，可互操作的JavaScript Promise的标准。 具体的规范可以看一下官方文档： 英文原文文档 中文翻译文档 实现一个简单的Promise根据文档我们知道Promise有几条基本要求： Promise是一个构造函数，接受一个回调函数为参数，并且该回调函数有两个函数类型的参数resolve、reject Promise共有三种状态：pengding、fulfilled、rejected，但Promise的当前状态只能是这三种状态中的一种，并且状态只能由pending转换为fulfilled/rejected这两种状态，改变为fulfilled/rejected状态后不可再改变。 状态改变只能通过调用resolve、reject两个函数进行。 需要提供一个then方法去访问当前值或者返回结果，then方法接受两个函数类型参数：onFulfilled、onRejected。 onFulfilled：当Promise状态为fulfilled时进行调用，并且接受Promise成功的值为参数。 onRejected：当Promise状态为rejected时进行调用，并且接受Promise失败的值为参数。 then方法返回一个新的Promise 根据这些要求我们可以先实现一个简易版的Promise：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const PENDING = &quot;pengding&quot;;const FULFILLED = &quot;fulfilled&quot;;const REJECTED = &quot;rejected&quot;;function MyPromise(fn) &#123; const self = this; self.status = PENDING; self.value = null; self.reason = null; function resolve(value) &#123; if (self.status === PENDING) &#123; self.status = FULFILLED; self.value = value; &#125; &#125; function reject(reason) &#123; if (self.status === PENDING) &#123; self.status = REJECTED; self.reason = reason; &#125; &#125; fn(resolve, reject);&#125;MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; const self = this; let bridgePromise = null; if (self.status === FULFILLED) &#123; return bridgePromise = new MyPromise((resolve, reject) =&gt; &#123; try &#123; let x = onFulfilled(self.value); resolve(x); &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125; if (self.status === REJECTED) &#123; return bridgePromise = new MyPromise((resolve, reject) =&gt; &#123; try &#123; let x = onRejected(self.reason); resolve(x); &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;&#125; 我们实现了这个简易的Promise，但是可以发现这个Promise是不支持异步操作的，所以接下来我们按照Promise/A+的规范，实现一个符合规范的Promise。 实现符合Promise/A+规范的Promise根据规范，我们上面实现的简易版，除了不能进行异步操作外，还缺少了一个resolvePromise函数去处理then函数中的回调函数的返回值。所以接下来我们一步步来实现。 增加异步操作首先我们需要定义两个保存回调函数的数组，分别保存onFulfilled回调函数和onRejected回调函数，并且在执行resolve或reject后，进行调用回调函数。123456789101112131415161718192021222324252627282930function MyPromise(fn) &#123; const self = this; self.status = PENDING; self.value = null; self.reason = null; // 存放onFulfilled回调处理函数集合 self.onFulfilledCallbacks = []; // 存放onRejected回调处理函数集合 self.onRejectedCallbacks = []; function resolve(value) &#123; if (self.status === PENDING) &#123; self.status = FULFILLED; self.value = value; // 修改状态后执行回调函数集合 self.onFulfilledCallbacks.forEach((callback) =&gt; callback(value)); &#125; &#125; function reject(reason) &#123; if (self.status === PENDING) &#123; self.status = REJECTED; self.reason = reason; //执行reject的回调函数，将reason传递到callback中 self.onRejectedCallbacks.forEach((callback) =&gt; callback(reason)); &#125; &#125; fn(resolve, reject);&#125; 然后修改一下then方法，需要加一个pengding状态的判断，将对应的回调函数，加入到回调函数集合中：123456789101112131415161718192021if(self.status === PENDING)&#123; return bridgePromise = new MyPromise(function(resolve, reject)&#123; self.onFulfilledCallbacks.push(value =&gt; &#123; try&#123; let x = onFulfilled(value); resolve(x); &#125;catch(e)&#123; reject(e) &#125; &#125;) self.onRejectedCallbacks.push(reason =&gt; &#123; try&#123; let x = onRejected(reason); resolve(x); &#125;catch(e)&#123; reject(e) &#125; &#125;) &#125;)&#125; 经过我们的改善，我们实现的简易版Promise已经支持异步操作了，接下来我们实现resolvePromise这个方法。 实现resolvePromise函数，处理回调函数结果resolvePromise函数是Promise/A+规范中，规定对Promise结果进行解析的处理程序，其中判断了多种Promise返回结果的情况，具体判断规则可以参考文档，这里我们来根据文档实现这个函数：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566function resolvePromise(bridgePromise, x, resolve, reject) &#123; /** * 2.3.1 如果返回的 bridgePromise 和 x 是指向同一个引用（循环引用），则抛出错误 */ if(bridgePromise === x)&#123; return reject(new TypeError(&apos;循环调用&apos;)); &#125; /** * 2.3.2 如果 x 是一个 promise 实例，则采用它的状态： * 2.3.2.1 如果 x 是 pending 状态，那么保留它（递归执行这个 promise 处理程序），直到 pending 状态转为 fulfilled 或 rejected 状态 * 2.3.2.2 如果或当 x 状态是 fulfilled，resolve 它，并且传入和 promise1 一样的值 value * 2.3.2.3 如果或当 x 状态是 rejected，reject 它，并且传入和 promise1 一样的值 reason */ if(x instanceof MyPromise)&#123; if(x.status === PENDING)&#123; x.then(y =&gt; &#123; resolvePromise(bridgePromise, y, resolve, reject); &#125;, error =&gt; &#123; reject(error); &#125;) &#125;else&#123; x.then(resolve, reject); &#125; &#125;else if(x != null &amp;&amp; ((typeof x === &apos;object&apos;) || (typeof x === &apos;function&apos;)))&#123; /** * 2.3.3 此外，如果 x 是个对象或函数类型 * 2.3.3.1 把 x.then 赋值给 then 变量 * 2.3.3.2 如果捕获（try，catch）到 x.then 抛出的错误的话，需要 reject 这个promise * 2.3.3.3 如果 then 是函数类型，那个用 x 调用它（将 then 的 this 指向 x）,第一个参数传 resolvePromise ，第二个参数传 rejectPromise： * 2.3.3.3.1 如果或当 resolvePromise 被调用并接受一个参数 y 时，执行[[Resolve]](promise, y) * 2.3.3.3.2 如果或当 rejectPromise 被调用并接受一个参数 r 时，执行 reject(r) * 2.3.3.3.3 如果 resolvePromise 和 rejectPromise 已经被调用或以相同的参数多次调用的话吗，优先第一次的调用，并且之后的调用全部被忽略（避免多次调用） * 2.3.3.4 如果 then 执行过程中抛出了异常， * 2.3.3.3.4.1 如果 resolvePromise 或 rejectPromise 已经被调用，那么忽略异常 * 2.3.3.3.4.2 否则，则 reject 这个异常 * 2.3.3.4 如果 then 不是函数类型，直接 resolve x（resolve(x)） */ // 判断是否已经调用的标识 let called = false; try &#123; let then = x.then; if(typeof then === &apos;function&apos;)&#123; then.call(x, y =&gt; &#123; if(called) return; called = true; resolvePromise(bridgePromise, y, resolve, reject); &#125;,error =&gt; &#123; if(called) return; called = true; reject(error); &#125;) &#125;else&#123; resolve(x); &#125; &#125; catch (error) &#123; if(called) return; called = true; reject(error); &#125; &#125;else&#123; resolve(x); &#125;&#125; resolvePromise函数已经实现，接下来我们完善一下then方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; const self = this; onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : reason =&gt; &#123;throw reason&#125;; let bridgePromise = null; if(self.status === FULFILLED)&#123; return bridgePromise = new MyPromise(function(resolve, reject)&#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(self.value); resolvePromise(bridgePromise, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;, 0); &#125;) &#125; if(self.status === REJECTED)&#123; return bridgePromise = new MyPromise(function(resolve, reject)&#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.reason); resolvePromise(bridgePromise, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;, 0); &#125;) &#125; if(self.status === PENDING)&#123; return bridgePromise = new MyPromise(function(resolve, reject)&#123; self.onFulfilledCallbacks.push(value =&gt; &#123; try &#123; let x = onFulfilled(value); resolvePromise(bridgePromise, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) self.onRejectedCallbacks.push(reason =&gt; &#123; try &#123; let x = onRejected(reason); resolvePromise(bridgePromise, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125;) &#125;&#125; 完善后的then方法中，你会发现我们多加了一些代码： 增加了onFulfilled和onRejected函数的判断，没有传入函数则给一个自定义函数，返回之前resolve的值，或者抛出异常，这也是Promise/A+的规范所要求的。 在fulfilled和rejected的状态返回值中都包了一层setTimeout，因为Promise的then方法都需要在下一轮的事件循环中被异步调用，所以我们模拟使用了setTimeout，原生的Promise则是使用微任务实现的，而pengding状态中没有加setTimeout，则是要在resolve和reject函数中进行异步调用回调函数集合,这是为了满足Promise/A+规范的2.2.4和2.2.6。 到此，我们已经把then方法完整的实现了，接下来我们将整个代码进行整合，然后进行测试。 符合Promise/A+规范的完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156const PENDING = &apos;pengding&apos;;const FULFILLED = &quot;fulfilled&quot;;const REJECTED = &quot;rejected&quot;;function MyPromise(fn) &#123; const self = this; self.status = PENDING; self.value = null; self.reason = null; self.onFulfilledCallbacks = []; self.onRejectedCallbacks = []; function resolve(value) &#123; if (value instanceof MyPromise) &#123; return value.then(resolve, reject); &#125; if(self.status === PENDING)&#123; setTimeout(() =&gt; &#123; self.value = value; self.status = FULFILLED; self.onFulfilledCallbacks.forEach((callback) =&gt; callback(self.value)); &#125;, 0); &#125; &#125; function reject(reason) &#123; if(self.status === PENDING)&#123; setTimeout(() =&gt; &#123; self.reason = reason; self.status = REJECTED; self.onRejectedCallbacks.forEach((callback) =&gt; callback(self.reason)); &#125;, 0); &#125; &#125; try &#123; fn(resolve, reject); &#125;catch(e)&#123; reject(e); &#125;&#125;function resolvePromise(bridgePromise, x, resolve, reject) &#123; if(bridgePromise === x)&#123; return reject(new TypeError(&apos;循环调用&apos;)) &#125; if(x instanceof MyPromise)&#123; if(x.status === PENDING)&#123; x.then(y =&gt; &#123; resolvePromise(bridgePromise, y, resolve, reject); &#125;, error =&gt; &#123; reject(error); &#125;) &#125;else&#123; x.then(resolve, reject); &#125; &#125;else if(x != null &amp;&amp; ((typeof x === &apos;object&apos;) || (typeof x === &apos;function&apos;)))&#123; let called = false; try &#123; let then = x.then; if(typeof then === &apos;function&apos;)&#123; then.call(x, y =&gt; &#123; if(called) return; called = true; resolvePromise(bridgePromise, y, resolve, reject); &#125;,error =&gt; &#123; if(called) return; called = true; reject(error); &#125;) &#125;else&#123; resolve(x); &#125; &#125; catch (error) &#123; if(called) return; called = true; reject(error); &#125; &#125;else&#123; resolve(x); &#125;&#125;MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; const self = this; onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : reason =&gt; &#123;throw reason&#125;; let bridgePromise = null; if(self.status === FULFILLED)&#123; return bridgePromise = new MyPromise(function(resolve, reject)&#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(self.value); resolvePromise(bridgePromise, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;, 0); &#125;) &#125; if(self.status === REJECTED)&#123; return bridgePromise = new MyPromise(function(resolve, reject)&#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.reason); resolvePromise(bridgePromise, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;, 0); &#125;) &#125; if(self.status === PENDING)&#123; return bridgePromise = new MyPromise(function(resolve, reject)&#123; self.onFulfilledCallbacks.push(value =&gt; &#123; try &#123; let x = onFulfilled(value); resolvePromise(bridgePromise, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) self.onRejectedCallbacks.push(reason =&gt; &#123; try &#123; let x = onRejected(reason); resolvePromise(bridgePromise, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125;) &#125;&#125;// 执行测试用例需要用到的代码MyPromise.deferred = function() &#123; let defer = &#123;&#125;; defer.promise = new MyPromise((resolve, reject) =&gt; &#123; defer.resolve = resolve; defer.reject = reject; &#125;); return defer;&#125;try &#123; module.exports = MyPromise&#125; catch (e) &#123;&#125; 代码已经整合完毕，我们可以利用Promise的测试脚本，对我们的代码进行测试：12npm i promises-aplus-tests -gpromises-aplus-tests promise.js]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React手动重新渲染子组件]]></title>
    <url>%2F2019%2F08%2F15%2FReact%E6%89%8B%E5%8A%A8%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%E5%AD%90%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[昨天在开发APP项目时，需要实现一个上传图片和视频，然后上传后的图片和视频进行轮播的功能，轮播图使用的是第三方插件react-native-snap-carousel，在ios中使用时没有出现过兼容性问题，只是需要在轮播的数据更新时，需要手动调用一下snapToItem方法，展示其对应的下标。然而在android中发现该方法并不生效，并且组件的firstItem属性也不会生效，就导致了上传后数据更新的时候下标依然保留在上一次，但是需求方想要每次展示最新上传的图片或视频。后来发现该组件的firstItem属性会在组件第一次渲染的时候生效，所以想到了一个方法就是将该组件进行手动卸载和挂载使其重新渲染。自己捣鼓了半天没有好的方法，后来在老大的指点下搞定了，然后在这记录一下，如何手动重新渲染子组件。直接上代码：123456789101112131415161718192021222324252627282930313233class Parent extends Component &#123; constructor(props) &#123; super(props); this.state=&#123; isShow: true &#125; &#125; componentDidUpdate(prevProps)&#123; // 判断是否需要更新 if(this.props.data != prevProps.data)&#123; // 先将组件卸载 this.setState(&#123; isShow: false &#125;) &#125; // 利用setTimeout异步操作，再将组件重新渲染， 不过会有一下抖动 setTimeout(() =&gt; &#123; this.setState(&#123; isShow: true &#125;) &#125;, 100) &#125; render() &#123; const &#123;isShow&#125; = this.state; return ( &lt;div&gt; &#123; isShow? &lt;Children/&gt;:null &#125; &lt;/div&gt; ) &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Antd的Form组件配合Mobx双向数据绑定]]></title>
    <url>%2F2019%2F08%2F09%2FAntd%E7%9A%84Form%E7%BB%84%E4%BB%B6%E9%85%8D%E5%90%88Mobx%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[最近忙于赶项目，一直没有时间去更新博客，今天得空，正好把最近在项目中使用Mobx和Antd中的Form组件进行双向数据绑定的方法记录一下。 为什么需要双向数据绑定？在后台管理系统中，表单是及其重要的，因为我们的增、改、查三个操作都需要用到表单。增加和查询一般是手动填入的，而修改则是需要将已有的数据先反显到表单中，再进行修改。这个反显的过程就需要对表单进行双向数据绑定了。 怎么进行双向数据绑定？在Antd的Form组件中，使用Form.create()包装组件后，该组件的props属性就会多一个form对象，该对象提供了一些api，具体的可以查看Antd的官方文档进行查看，其中getFieldDecorator是该组件提供的双向数据绑定的api。直接上代码来看用法：1234567891011&lt;Form&gt; &lt;Form.Item&gt; &#123;getFieldDecorator(&apos;username&apos;, &#123; rules: [&#123; required: true, message: &apos;Please input your username!&apos; &#125;], &#125;)( &lt;Input placeholder=&quot;Username&quot; /&gt; )&#125; &lt;/Form.Item&gt;&lt;/Form&gt; 用法很简单，将控件对应的key值和配置项传入到getFieldDecorator函数中，然后再使用getFieldDecorator包装控件。这个配置项具体有哪些参数可以去查看官方文档，目前我在项目中用的比较多的就是校验功能，也就是rules配置，使用该参数可以配置校验规则和提示。但是使用getFieldDecorator函数也有antd定制的规则： 经过getFieldDecorator包装的控件，表单控件会自动添加value和onChange，数据同步将被Form接管。 不再需要也不应该用onChange来做同步，但还是可以继续监听onChange等事件。 不能用控件的value、defaultValue等属性来设置表单域的值，默认值可以用getFieldDecorator里的initialValue。 不应该用setState，可以使用this.props.form.setFieldsValue来动态改变表单值。有了这些规则后，说明我们不能去使用value和onChange配合使用进行双向数据绑定了，而是要使用this.props.form.setFieldsValue来设置值，但是这样通过onChange又是及其的繁琐。 使用Mobx数据双向数据绑定在我的项目中，用的状态管理库为Mobx，如何将Mobx中观察的数据传入到Form组件中，我们走了很多弯路，开始我们发现getFieldDecorator函数的配置项中提供了一个initialValue的属性，使用该属性可以将Mobx的数据反显到表单控件中，但是该属性仅是表单控件的初始值，类似于defaultValue的功能，所以只要我们在页面中手动触发了控件的value改变，initialValue就不会再生效了，也就是说反显是ok的，但是如果要操作就会出问题。后面仔细阅读文档后，发现Form.create()函数中提供了mapPropsToFields和onFieldsChange两个api，这两个api配合使用可以将Mobx观察的数据传入到Form组件中，而且组件修改时也能实时传入到Mobx中。具体用法如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 将mobx中观察的数据 转换为mapPropsToFields所需要的结构const objToForm = (obj = &#123;&#125;) =&gt; &#123; const target = &#123;&#125;; for(const [key,value] of Object.entries(obj))&#123; if(typeof value == &apos;object&apos; &amp;&amp; !Array.isArray(value))&#123; target[key] = Form.createFormField(value); &#125;else&#123; target[key] = Form.createFormField(&#123;value&#125;); &#125; &#125; return target;&#125;const onFieldsChange = (props, changedFields) =&gt; &#123; props.setQueryData(&#123;...props.queryData, ...changedFields&#125;);&#125;;const mapPropsToFields = (props) =&gt; &#123; return objToForm(props.queryData);&#125;;@Form.create(&#123; mapPropsToFields, onFieldsChange&#125;)class Index extends Component &#123; constructor(props) &#123; super(props); this.state=&#123;&#125;; &#125; render() &#123; const &#123;getFieldDecorator&#125; = this.props.form; return ( &lt;Form&gt; &lt;Form.Item&gt; &#123;getFieldDecorator(&apos;username&apos;, &#123; rules: [&#123; required: true, message: &apos;Please input your username!&apos; &#125;], &#125;)( &lt;Input placeholder=&quot;Username&quot; /&gt; )&#125; &lt;/Form.Item&gt; &lt;/Form&gt; ); &#125;&#125; 主要是要将mapPropsToFields方法中接受的Mobx数据转换为Form组件可接受的数据结构，并且使用Form.createFormField包装数据，而onFieldsChange方法则是将当前改变的控件数据再提供给Mobx去使用，这样就形成了一个双向数据绑定的效果。但是需要注意的是，onFieldsChange函数提供的数据并不是简单的key: value这种直接可以使用的键值对了，如果需要拿到表单数据进行接口交互的话，需要再将Mobx中的数据进行转换一下，或者直接使用this.props.form.validateFields方法拿到校验通过的所有表单数据来进行交互。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Antd</tag>
        <tag>Mobx</tag>
        <tag>Form</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React生命周期执行顺序详解]]></title>
    <url>%2F2019%2F05%2F15%2FReact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不管是使用React还是Vue，生命周期都是我们必须掌握的。最近在面试的时候，很多人搞不清楚React的生命周期的执行顺序，所以写一篇文章来解析一下React的生命周期函数的执行顺序。本文只介绍常用的生命周期函数的执行顺序，所以有部分不常用的执行顺序可以去看React官方文档。我们先看一张官方文档中的生命周期图谱（v16.4）：根据这个图，我们可以分三个阶段来解析React的生命周期执行顺序： 组件初始化创建(Mounting)阶段此阶段的顺序为：constructor -&gt; componentWillMount -&gt; render -&gt; ComponentDidMount。由于React新的版本中将一些生命周期函数标记为‘过时’，所以在图谱中我们没有看到componentWillMount，但是现在依然可以使用这个生命周期函数。我们可以看下面这行代码来检验这个阶段的执行顺序：1234567891011121314151617181920class Index extends Component &#123; constructor(props) &#123; super(props); console.log(&apos;constructor&apos;); &#125; componentWillMount() &#123; console.log(&apos;componentWillMount&apos;); &#125; componentDidMount() &#123; console.log(&apos;componentDidMount&apos;); &#125; render() &#123; console.log(&apos;render&apos;); return ( &lt;div&gt; render &lt;/div&gt; ) &#125;&#125; 打开chrome浏览器检验一下结果：这个顺序没有什么疑问，但是如果是嵌套组件呢？父子组件之前的顺序是什么样的呢？ 嵌套组件初始化创建阶段我们再看一段代码：1234567891011121314151617181920212223242526272829303132333435363738394041class Parent extends Component &#123; constructor(props) &#123; super(props); console.log(&apos;constructor---Parent&apos;); &#125; componentWillMount() &#123; console.log(&apos;componentWillMount---Parent&apos;); &#125; componentDidMount() &#123; console.log(&apos;componentDidMount---Parent&apos;); &#125; render() &#123; console.log(&apos;render---Parent&apos;); return ( &lt;div&gt; &lt;Child /&gt; &lt;/div&gt; ) &#125;&#125;class Child extends Component &#123; constructor(props) &#123; super(props) console.log(&apos;constructor---Child&apos;) &#125; componentWillMount() &#123; console.log(&apos;componentWillMount---Child&apos;) &#125; componentDidMount() &#123; console.log(&apos;componentDidMount---Child&apos;) &#125; render() &#123; console.log(&apos;render---Child&apos;) return ( &lt;div&gt; Child &lt;/div&gt; ) &#125;&#125; 这是一个最普通的嵌套组件，我们在chrome中检验一下结果：我们可以看到嵌套组件的执行顺序为： 父组件：constructor -&gt; componentWillMount -&gt; render； 在父组件render的时候开始初始化创建子组件； 子组件：constructor -&gt; componentWillMount -&gt; render -&gt; componentDidMount； 最后子组件执行完毕后，再回到父组件执行componentDidMount。 组件更新(Updating)阶段如果要触发组件更新有两种情况（不考虑Redux、Mobx等数据流管理工具）： setState更新state后触发组件自身更新 父组件更新后触发子组件的更新 第一种情况是当前组件内部的更新，第二种情况是由于父组件更新导致子组件的更新。这两种情况都会触发更新，但是有部分生命周期函数的执行不一样，我们先看第一种情况： setState触发的组件自身更新先看下面一段代码：1234567891011121314151617181920212223242526272829303132class Index extends Component &#123; constructor(props) &#123; super(props); console.log(&apos;constructor&apos;); this.state=&#123; count: 0 &#125; &#125; componentWillMount() &#123; console.log(&apos;componentWillMount&apos;); &#125; componentDidMount() &#123; console.log(&apos;componentDidMount&apos;); this.setState(&#123; count: 1 &#125;) &#125; componentWillUpdate()&#123; console.log(&apos;componentWillUpdate&apos;) &#125; componentDidUpdate()&#123; console.log(&apos;componentDidUpdate&apos;); &#125; render() &#123; console.log(&apos;render&apos;); return ( &lt;div&gt; Index &lt;/div&gt; ) &#125;&#125; 接着在chrome中验证一下结果：通过这个结果我们可以得到以下的结论：更新state后的组件自身更新生命周期执行顺序：componentWillUpdate -&gt; render -&gt; componentDidUpdate 父组件更新触发的子组件更新这种情况是在嵌套组件中，直接上代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Parent extends Component &#123; constructor(props) &#123; super(props); console.log(&apos;constructor---Parent&apos;); this.state=&#123; count: 0 &#125; &#125; componentWillMount() &#123; console.log(&apos;componentWillMount---Parent&apos;); &#125; componentDidMount() &#123; console.log(&apos;componentDidMount---Parent&apos;); this.setState(&#123; count: 1 &#125;) &#125; componentWillUpdate()&#123; console.log(&apos;componentWillUpdate---Parent&apos;) &#125; componentWillReceiveProps(nextProps)&#123; console.log(&apos;componentWillReceiveProps---Parent&apos;) &#125; componentDidUpdate()&#123; console.log(&apos;componentDidUpdate---Parent&apos;); &#125; render() &#123; console.log(&apos;render---Parent&apos;); return ( &lt;div&gt; &lt;Child /&gt; &lt;/div&gt; ) &#125;&#125;class Child extends Component &#123; constructor(props) &#123; super(props) console.log(&apos;constructor---Child&apos;) this.state = &#123;&#125; &#125; componentWillMount() &#123; console.log(&apos;componentWillMount---Child&apos;) &#125; componentDidMount() &#123; console.log(&apos;componentDidMount---Child&apos;) &#125; componentWillReceiveProps(nextProps)&#123; console.log(&apos;componentWillReceiveProps---Child&apos;) &#125; componentWillUpdate(nextProps, nextState) &#123; console.log(&apos;componentWillUpdate---Child&apos;) &#125; componentDidUpdate(prevProps, prevState) &#123; console.log(&apos;componentDidUpdate---Child&apos;) &#125; render() &#123; console.log(&apos;render---Child&apos;) return ( &lt;div&gt; Child &lt;/div&gt; ) &#125;&#125; 在chrome中验证一下结果：从这个结果中我们可以看到，只有子组件的componentWillReceiveProps方法执行了，我们可以得到以下结论： 父组件执行更新：componentWillUpdate -&gt; render 父组件render后开始更新子组件 子组件执行更新：componentWillReceiveProps -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate 子组件更新完毕后，父组件执行componentDidUpdate，结束更新。 组件卸载(Unmounting)阶段在这个阶段，组件只会执行一个生命周期函数：componentWillUnmount，在这个函数中，我们可以做一些初始化数据的操作。防止组件下次渲染的时候保留了上次的数据。同上面两个阶段，这个阶段，也会出现在嵌套组件中，但是却和之前的执行顺序不太一样： 父组件执行componentWillUnmount 子组件执行componentWillUnmount 结语通过上面的解析，我们可以清晰的知道组件的生命周期执行顺序了： 初始化创建组件阶段： 父组件：constructor -&gt; componentWillMount -&gt; render -&gt; 子组件：constructor -&gt; componentWillMount -&gt; render -&gt; componentDidMount -&gt; 父组件：componentDidMount 更新阶段： 父组件：componentWillUpdate -&gt; render -&gt; 子组件：componentWillReceiveProps -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate -&gt; 父组件：componentDidUpdate 卸载阶段： 父组件：componentWillUnmount 子组件：componentWillUnmount 通过这些代码的检验，得到了以上的结论，当然这些生命周期函数只是常用的，还有一些不常用的大家可以参考一下官网文档。其中有一个shouldComponentUpdate函数是React控制组件更新进行优化的一个生命周期函数，大家可以了解一下。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setState同步异步问题]]></title>
    <url>%2F2019%2F05%2F04%2FsetState%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在React开发中，setState一般都会被认为是异步的。但是最近在掘金上看到一篇文章 你真的理解setState吗？ ，看完后发现setState并不是想象中的异步那么简单。 setState是异步的吗？在React官方文档中，有这样一段话： setState()不总是立刻更新组件。其可能是成批处理或推迟更新。这使得在调用setState()后立刻读取this.state变成一个潜在陷阱。代替地，使用componentDidUpdate或一个setState回调（setState(updater, callback)），当中的每个方法都会保证在更新被应用之后触发。 读完这段话，我们本能的认为setState就是异步的，因为连官方都推荐我们在componentDidUpdate生命周期和setState的callback中去读取this.state。接下来我们用代码去检验一下setState的同步异步： 生命周期中的setState123456789101112131415161718192021222324252627class Index extends Component &#123; constructor(props) &#123; super(props); this.state=&#123; count: 0 &#125; &#125; componentDidMount() &#123; this.setState(&#123; count: 1 &#125;) console.log( this.state.count ) &#125; componentDidUpdate()&#123; console.log(this.state.count) &#125; render() &#123; return ( &lt;div&gt; 测试 &lt;/div&gt; ) &#125;&#125; 在上面这个例子中，我们在componentDidMount中使用setState去更新了count，然后立马打印了一下count；接着在componentDidUpdate中我们也打印了一下count,然后我们在chrome中查看一下控制台，输出为：0 1。这个结果我们并不意外，在开发中这种代码是我们经常遇到，这也说明在生命周期中setState是异步的。 合成事件中的setState123456789101112131415161718192021222324252627class Index extends Component &#123; constructor(props) &#123; super(props); this.state=&#123; count: 0 &#125; &#125; onClick = () =&gt; &#123; this.setState(&#123; count: 1 &#125;) console.log(this.state.count) &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.onClick&#125; &gt; 测试 &lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 看一下这个例子中，我们在onClick事件中使用setState去更新count，接着立马打印了count；我们到chrome中去验证一下，发现打印的还是0，这说明在合成事件中setState也是异步的。 setTimeout中的setState12345678910111213141516171819202122232425class Index extends Component &#123; constructor(props) &#123; super(props); this.state=&#123; count: 0 &#125; &#125; componentDidMount() &#123; setTimeout(() =&gt; &#123; this.setState(&#123; count: 1 &#125;) console.log(this.state.count) &#125;, 0) &#125; render() &#123; return ( &lt;div&gt; 测试 &lt;/div&gt; ) &#125;&#125; 在这个例子中，我们在componentDidMount中定义了一个setTimeout，并且在回调函数中使用setState更新count，然后打印了count；我们在chrome中验证一下，发现控制台中输出的是：1。这个和前面的结果不同，count被实时读取到了，也说明在setTimeout中setState是同步的。 原生事件中的setState1234567891011121314151617181920212223242526272829class Index extends Component &#123; constructor(props) &#123; super(props); this.state=&#123; count: 0 &#125; &#125; componentDidMount() &#123; document.querySelector(&apos;button&apos;).addEventListener(&apos;click&apos;, this.onClick, false) &#125; onClick = () =&gt; &#123; this.setState(&#123; count: 1 &#125;) console.log(this.state.count) &#125; render() &#123; return ( &lt;div&gt; &lt;button&gt; 测试 &lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 在上面的例子中，我们给button按钮使用原生addEventListener的方式，绑定了click事件，并在click事件中使用setState去更新count，然后立马打印了count，接下来我们在chrome中验证一下，发现控制台中输出的是：1。这个结果和setTimeout中setState的结果一致，说明在原生事件中setState也是同步的。 结论通过上面的例子，我们可以得到一下结论： 在生命周期函数中，setState是异步的； 在合成事件中，setState是异步的； 在异步操作中，setState是同步的； 在原生事件中，setState是同步的。 目前得到了这些结论，但是我们并不清楚其中的原理是什么，我查阅了一些资料，发现自己还是不能理解其中奥妙，所以就不在此误导大家，但是自己会努力学习理解这个问题。不过大家可以参考下面文章去发现更深层次的原理： 你真的理解setState吗？]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS事件循环(Event Loop)]]></title>
    <url>%2F2019%2F04%2F11%2FJS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日常开发中，总会出现各种因为同步异步行为导致的问题。最近和同事们讨论React中setState同步异步的问题，在网上看到一些解析和总结，发现自己其实对js的执行机制并不太理解。因此在网上查阅了一些资料，来完善一下自己的知识，本文是自己记录一下对js执行机制的理解。先看一段代码:1234567891011setTimeout(function()&#123; console.log(&apos;a&apos;)&#125;,0)console.log(&apos;b&apos;)setTimeout(function()&#123; console.log(&apos;c&apos;)&#125;,1000)console.log(&apos;d&apos;)setTimeout(function()&#123; console.log(&apos;e&apos;)&#125;,0) 按照js是一门单线程语言，代码是从上到下的顺序执行的，我们会很正常的认为打印的结果是abdec,但是去chrome中验证下，却发现结果并不是这样。 同步和异步原来js中将代码执行分为了同步和异步，当同步代码执行完毕后，才会去执行异步代码。setTimeout、setInterval、callback、Promise等，都属于异步操作。但是具体的执行机制是什么呢？我们可以看下面这张图(出处在文章尾部):从这张图里我们可以知道: js会将任务分为同步任务和异步任务，同步任务进入主线程，异步任务进入Event Table，并且注册回调函数， 回调函数进入Event Queue; 主线程的任务执行完毕，到Event Queue中读取对应的函数，然后进入主线程去执行。以上会重复执行，这就是js的执行机制，也是事件循环(Event Loop)。 知道了这些后，再看上面的代码，我们知道了setTimeout属于异步操作，会进入Event Table,等待主线程任务执行完毕才会去执行。但是setTimeout(function(){},0)是不是会立即呢？答案是不会。因为setTimeout(fn, 0)是指当主线程任务执行完毕后会立即执行，不需要再等待多少秒后再执行，所以我们会看到这段代码的结果是bdaec。 接着我们再看一段代码:12345678910setTimeout(function()&#123; console.log(&apos;a&apos;)&#125;,0)new Promise(function(resolve)&#123; console.log(&apos;b&apos;) resolve()&#125;).then(res =&gt; &#123; console.log(&apos;c&apos;)&#125;)console.log(&apos;d&apos;) 按照我们上面的同步异步的执行机制，我们可以知道这段代码会进行以下操作： 异步代码setTimeout进入Event Table 执行同步代码Promise，打印b Promise.then进入Event Table 执行同步代码，打印d 主线程执行完毕，到Event Queue中读取对应的函数，并放到主线程中执行 按照之前的理解，这个时候应该是先打印a再打印c，但是我们到chrome中验证一下发现结果是先打印c再打印a，这是为什么呢？ 宏任务和微任务查阅了一些文章后，原来js将任务分为了更精细的宏任务(macro-task)和微任务(micro-task): 宏任务：包括整体代码的script、setTimeout、setInterval 微任务：Promise、process.nextTick(暂不了解,后续学习) 宏任务和微任务之间的执行顺序又是什么呢？我们看下面这张图(出处在文章尾部):从这张图里我们可以知道： js将代码分为宏任务和微任务，先进入宏任务中执行 宏任务执行结束后，查看是否有可执行的微任务 有微任务就执行微任务，然后进行下一个宏任务 没有微任务则直接进行下一个宏任务 那么再看我们之前的代码，我们就可以明白为什么结果是先打印c再打印a: 整段代码作为宏任务进入主线程 setTimeout进入Event Table，然后注册回调函数，分发宏任务到Event Queue new Promise立即执行，打印b，then进入Event Table, 注册回调函数，分发微任务到Event Queue console.log()立即执行，打印d 到此第一个宏任务执行完毕，然后查看是否有微任务 有微任务then函数，则执行then函数，打印c 微任务执行完毕，开始执行新的宏任务setTimeout的回调函数,打印a 由此我们就了解到js的执行机制。 结语本文是在看到一些文章后，自己所理解的js执行机制，如有不对，请指出。写完这篇文章后，自己对js的事件循环也有了一个大概的了解，虽然具体的原理和底层的堆、栈等还一知半解，但是后续会努力学习加深自己的理解。 参考文章 这一次，彻底弄懂 JavaScript 执行机制]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用记录]]></title>
    <url>%2F2019%2F03%2F29%2FGit%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[最近工作中使用Git来进行代码管理，由于之前一个人折腾，并不会遇到太多冲突代码的问题，所以遇到冲突的情况，就会导致需要去各种百度查文档才能解决。因此写一篇文章记录自己常用的命令和流程，以及遇到的问题和解决方法。 基础语法设置用户名和邮箱git config --global user.name &#39;用户名&#39;git config --global user.email &#39;用户邮箱&#39; 初始化仓库初始化仓库有两种方法：第一种是直接在当前目录把所有文件导入到Git中；第二种是从远程服务器克隆一个Git仓库到本地。 git init 执行该命令会在在当前目录中初始化一个Git仓库，创建一个.git的文件夹，这个.git文件夹中包含了所有初始化Git仓库必须的文件，是Git的核心。 git clone [远程服务器仓库地址] [本地目录名] 如果想获取一份已经存在远程服务器上的Git仓库，则执行该命令即可。可在服务器url参数后添加一个本地仓库的名字。 查看文件状态git status执行该命令可以看到当前哪些文件处于什么状态。目前我所知道的有以下几个状态： modified: 文件被修改 new file: 新增的文件 deleted: 文件被删除 renamed: 文件重命名 both modified: 文件有冲突 提交代码到本地仓库在使用查看完文件状态后，如果文件状态有所改变，我们可以将文件提交到本地仓库。git add [option]使用该命令可以将修改的文件放到暂存区，或者追踪新的文件并放到暂存区。option参数可以传.、*、-A、-u、文件夹、文件。 git add .: 会把工作区所有变化提交到暂存区，包括modified和new file状态的，但是不包括deleted的状态。 git add *: 和git add .功能一样，但是不会提交以.开头的文件。 git add -u: 会把工作区已经放到暂存区的文件进行更新(包括modified和deleted)，但是不会提交新增文件(new file)。即只监控已经add的文件。 git add -A: 提交工作区所有变化，git add .和git add -u的合集。 git add 文件夹: 提交当前文件夹所有更改到暂存区。 git add 文件: 提交当前文件到暂存区。 git commit -m &#39;remark&#39;使用该命令可以将暂存区的文件，提交到本地仓库。remark代表本次提交说明。git commit -a -m &#39;remark&#39;使用该命令可以省略git add命令，直接把所有已经追踪过的文件暂存起来提交到本地仓库(是否包含新文件，待验证)。 查看提交历史git log执行该命令后，可以看到根据提交时间排序的所有信息，这些信息包括提交的SHA-1值(commit_id)，作者，提交时间，提交说明等。 取消暂存文件或者文件的修改git rest HEAD [文件名]执行该命令后，可以把已经add的文件取消暂存。git checkout -- [文件名]执行该命令后，可以撤销该文件所有的修改(撤销后无法恢复)。 撤销commit提交git reset --[option] [commit_id]执行该命令后，可以将已经commit的修改进行撤销，根据option的不同，会出现不同的结果： soft: 会将已经commit的修改，撤销到暂存区 mixed: 不会把已经commit的修改，撤销到暂存区 hard: 撤销已经commit的修改，并且不会保留。 拉取远程仓库代码git pull如果本地分支已经跟踪了远程分支，执行该命令后，会拉取远程分支代码并且合并到本地分支。git fetch [远程仓库名]执行该命令后，会拉取远程仓库所有本地没有的数据到本地仓库，但是并不会自动合并和修改当前的分支，需要手动合并到当前分支。(目前还没有使用过，后续使用会再进行深入理解。) 提交当前代码到远程仓库git push [远程仓库] [分支名]使用该命令，会将已经commit到本地仓库的代码提交到远程仓库中。如果本地分支与远程分支关联了，直接git push即可，如果没有，则需要加上远程仓库名和分支名称，例如: git push origin master。 添加远程仓库git remote add [仓库名] [远程仓库地址]如果使用了git init初始化一个Git仓库后，想要把代码提交到远程仓库，可以使用该命令将本地仓库和远程仓库关联起来。如果已经有远程仓库了，也可以使用该命令再新增一个远程仓库，不过在拉取代码的时候需要指定仓库名。 使用分支git branch [option] [分支名] [远程仓库名/远程分支名]执行该命令后，可以查看到当前本地所有分支列表，分支名前带*的是当前所处的分支。目前我所知道的option参数有以下: -a: 展示所有分支，包括本地和远程。 -v: 查看本地每一个分支最后一次提交。 -d: 删除分支。 -D: 强制删除分支。 -vv: 查看本地分支和其所关联的远程分支。 如果git branch后直接写分支名，则是创建一个新分支；如果分支名后加上远程仓库名/远程分支名，则可以创建一个关联到远程分支的本地分支。例如:git branch test origin/test使用该命令后则可以在本地创建一个关联到远程test分支的test分支。使用git branch -u [远程仓库名/远程分支名]可以使当前分支关联到远程分支，如果当前分支已经关联远程分支，那么该操作则会更改当前分支关联的远程分支。git checkout [分支名]执行该命令后，可以切换到对应的分支下。使用git checkout -b [分支名]可以快速创建一个新分支，并且切换到该分支。使用git checkout -b [分支名] [远程仓库名/分支名]可以新建一个关联到远程分支的分支，并且切换到该分支；也可以使用git checkout --track [远程仓库名/分支名],但是创建的分支名会和远程分支相同。git checkout [分支名] [文件目录]在当前分支下执行该命令，会将对应分支名下的文件目录覆盖到当前分支对应的文件目录。git push [远程仓库名] [分支名]执行该命令可以将当前分支代码提交到对应远程分支，如果远程没有对应分支，则会新建一个远程分支并且提交。 储藏git stash执行该命令后，会将当前分支下的所有修改和暂存进行储藏，保存到一个栈上。储藏后的分支是一个干净的目录，可以直接拉取远程代码，并且不会出现任何冲突。git stash list执行该命令后，会列出所有进行过的储藏。stash@{数字}代表储藏的名字。git stash apply [储藏名]执行该命令后，可以将对应储藏名的储藏修改应用到当前分支上，不传储藏名则默认应用最新的储藏。该操作不会删除储藏，如果想要在应用储藏后移除储藏则可以使用git stash drop [储藏名]来移除储藏。git stash pop [储藏名]执行该命令后，会将对应储藏应用到当前分支，并且移除储藏。不传储藏名，则默认应用最新的储藏，并且移除它。 删除没有被追踪的文件git clean [option]执行该命令后，会将没有add的文件和文件夹删除，具体option参数如下: -n：会展示哪些文件要被删除，但是不会去做删除操作，只是用来提示 -f：删除当前目录下没有被追踪过的文件，不会删除.gitignore文件里面指定的文件 -f ：删除对应路径下的文件 -df：删除当前目录下没有被追踪过的文件和文件夹 -xf：删除当前目录下所有没有追踪过的文件. 不管他是否是.gitignore文件里面指定的文件夹和文件 目前工作中的使用流程当前我所使用的提交流程123456789git status // 查看当前分支状态git stash // 储藏当前修改git pull // 拉取远程分支代码git stash pop // 应用上次储藏git status // 查看应用储藏后的状态********* // 解决冲突和合并git add [目录] // 暂存对应目录下的修改git commit -m &apos;remark&apos; // 提交到本地仓库git push // 提交到远程仓库 结束语以上只是我目前所使用过和了解的一些语法和流程，目前只是很浅显的知道如何使用git去管理代码，其中的原理还不知其所以然，后续会抽时间去研究一下做补充，也会把自己遇到的问题和解决方法也记录在这里。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloWorld]]></title>
    <url>%2F2019%2F03%2F26%2FHelloWorld%2F</url>
    <content type="text"><![CDATA[新的开始经历了一些事情，终于狠下心来买了人生的第一台MacBook Pro，也折腾了两三天，把自己的博客又重新搭了起来；希望从今天开始，自己能够坚持记录生活和工作上的一些事！加油！！！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
