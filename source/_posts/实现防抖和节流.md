---
title: 实现防抖和节流
date: 2020-04-26 21:37:30
tags: 
    - JavaScript
---
在业务开发场景中，我们经常会使用到防抖和节流，我一般都是使用`Lodash`工具库直接调用这两个方法，今天自己来实现一下这两个方法。

## 防抖(debounce)
防抖的含义：触发高频事件在n秒以后执行，如果在n秒之内再次触发事件，则重新计算时间
防抖的应用场景：
* autoComplete组件
- 实时搜索框

实现思路：
利用闭包缓存一个时间为n秒计时器，每次触发事件时，清除上一个计时器。
代码：
```
function debounce(fn, time) {
    // 利用闭包缓存一个定时器
    let timeout = null;
    return function () {
        // 每次执行 则先清除上一个定时器
        clearTimeout(timeout);
        timeout = setTimeout((a) => {
            // 执行事件
            fn.apply(this, arguments)
        }, time);
    }
}               
```

## 节流(throttle)
节流的含义：触发高频事件后，在n秒内只执行一次
节流的应用场景：
* 监听滚动事件，实现懒加载等
- 防止用户连续频繁的点击事件，如提交按钮等

实现节流有两种方案：
* 利用闭包缓存一个是否可以执行函数的变量，配合定时器去修改变量来执行函数。
- 利用闭包缓存上一次的时间戳，判断当前执行的时间和上一次时间的间隔是否大于规定时间。

定时器代码实现：
```
        function throttle(fn, time) {
            // 设置一个标识 来判断延时函数是否可以执行，默认可以执行
            let isCanRun = true;
            return function () {
                // 每次执行先判断是否可以执行延迟函数
                if(!isCanRun) return;
                // 将标识设置为false，表示有延时函数需要执行
                isCanRun = false;
                setTimeout(() => {
                    fn.apply(this, arguments);
                    // 在函数执行完后 延时将标识设置为true，
                    isCanRun = true;
                }, time);
            }
        }
```

时间戳代码实现：
```
        function throttle(fn, time) {
            // 缓存上次执行时间的变量
            let activeTime = 0;
            return function () {
                // 获取每次执行的时间戳
                const curTime = +new Date();
                // 判断当前执行的时间和缓存的时间戳的时间差是否大于要延时的时间 
                if( curTime - activeTime > time ){
                    fn.apply(this, arguments);
                    // 缓存当前时间
                    activeTime = curTime;
                }
            }
        }
```
