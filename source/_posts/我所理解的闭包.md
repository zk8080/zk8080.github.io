---
title: 我所理解的闭包
date: 2020-04-29 09:45:35
tags:
    - JavaScript
---
在我的上一篇文章[实现防抖和节流](https://zkat.site/2020/04/26/%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/)中，都是利用闭包缓存变量去实现的，那么今天就来说一下我所理解的闭包是什么。这也是面试中必不可少的部分。本文参考了冴羽大神的JavaScript深入系列的[JavaScript深入之执行上下文](https://github.com/mqyqingfeng/Blog/issues/8)和[JavaScript深入之闭包](https://github.com/mqyqingfeng/Blog/issues/9)，大家可以深入了解下。

## 闭包的概念
MDN中对闭包的定义为：
>函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。

按照这段话的理解，那么每个函数都会形成一个闭包，这和我们平时所理解的闭包不太一样，但是这是理论上的闭包定义，还有一个实践角度上的闭包：
* 即使创建该函数的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
- 在代码中引用了自由变量

>自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。

## 闭包是怎么形成的
我们来看一段MDN上的示例代码：
```js
function makeFunc() {
    var name = "Mozilla";
    function displayName() {
        console.log(name);
    }
    return displayName;
}

var myFunc = makeFunc();
myFunc();
```
我们来分析一下这段代码的执行上下文栈和执行上下文的变化情况，不了解代码是怎么执行代码并创建对应执行上下文的，可以去看一下冴羽大神的[JavaScript深入之执行上下文](https://github.com/mqyqingfeng/Blog/issues/8)。执行过程如下：
1. 执行全局代码，创建全局上下文，全局上下文被压入执行上下文栈：
```
ECStack = [
    globalContext
]
```
2. 全局上下文初始化：
```
globalContext = {
    VO: [global],
    Scope: [globalContext.VO],
    this: globalContext.VO
}
```
3. 初始化的同时，创建makeFunc函数，保存作用域链到函数的内部属性[[scope]]:
```
makeFunc.[[scope]] = [
    globalContext.VO
]
```
4. 执行makeFunc函数，创建makeFunc函数上下文，makeFunc函数上下文被压入执行上下文栈：
```
ECStack = [
    globalContext,
    makeFuncContext
]
```
5. makeFunc函数上下文初始化，合并作用域链，同时displayName函数也被创建：
```
makeFuncContext = {
    AO: {
        arguments: {
            length: 0
        },
        name: undefined,
        displayName: reference to function displayName(){}
    },
    Scope: [AO, globalContext],
    this: undefined
}
displayName.[[scope]] = [
    makeFuncContext.AO,
    globalContext.VO
]
```
6. makeFunc函数执行过程中更新AO：
```
makeFuncContext = {
    AO: {
        arguments: {
            length: 0
        },
        name: "Mozilla",
        displayName: reference to function displayName(){}
    },
    Scope: [AO, globalContext.VO],
    this: undefined
}
```
7. makeFunc函数执行完毕，makeFunc函数上下文从执行上下文栈中弹出：
```
ECStack = [
    globalContext
]
```
8. 执行displayName函数，创建displayName函数上下文，displayName函数上下文压入执行上文栈中：
```
ECStack = [
    globalContext,
    displayNameContext
]
```
9. 初始化displayName函数上下文，合并作用域链：
```
displayNameContext = {
    AO: {
        arguments: {
            length: 0
        }
    },
    Scope: [AO, makeFuncContext.AO, globalContext.VO],
    this: undefined
}
```
10. 执行displayName函数，发现函数内部用到变量name，而displayNameContext.AO中并没有name值，沿着作用域链往上找，在makeFuncContext.AO中找到name值，为Mozilla，则打印Mozilla。displayName函数执行完毕，displayName函数上下文从执行上下文中弹出：
```
ECStack = [
    globalContext
]
```

通过上面的解析，我们可以发现，在makeFunc函数上下文从执行上下文栈中弹出后，displayName函数依然存在，并且拥有一个作用域链。所以当makeFuncContext被销毁时，makeFuncContext.AO依然存在于内存中。这就是为什么displayName函数可以读取到makeFuncContext中的值。再结合我们对闭包的实践角度上的定义对比一下，我们发现，displayName函数就是一个典型的闭包。

## 闭包经典面试题
面试中提到闭包，那么这道题必不可少：
```js
var data = [];
for (var i = 0; i < 3; i++) {
    data[i] = function () {
        console.log(i);
    };
}
data[0]();
data[1]();
data[2]();
```
毋庸置疑，打印的都是3，因为当函数执行的时候，for循环已经执行结束，全局变量i值已经是3了。所以函数执行的时候，去查找变量i，当前函数上下文的AO中没有i，查找globalContext.VO，i为3，所以打印3。
那么如何让这段代码打印成0，1，2？ 那么答案就是闭包。利用闭包缓存变量，使其在每次执行的时候都能查找到对应作用域链中缓存的变量。代码如下：
```js
var data = [];
for (var i = 0; i < 3; i++) {
    data[i] = (function(i){
        return function () {
            console.log(i);
        };
    })(i)
}
data[0]();
data[1]();
data[2]();
```
这样修改后，data[0]函数中的作用域链就是：
```
data[0]Context = {
    Scope: [AO, 匿名函数Context.AO, globalContext.VO]
}
```
匿名函数上下文的AO:
```
匿名函数Context = {
    AO: {
        arguments: {
            0: 0
            length: 1,
        }
        i: 0
    }
}
```
所以当打印i值的时候，去作用域链中查找的时候，在匿名函数Context.AO找到了i为0，找了i值后就不会再往globalContext.VO中去查找了。data[1]和data[2]函数同理。
当然这道题还有别的解法：
1. 函数内部使用局部变量保存i值
```js
var data = [];
for (var i = 0; i < 3; i++) {
    data[i] = (function(){
        var j = i;
        return function () {
            console.log(j);
        };
    })()
}
data[0]();
data[1]();
data[2]();
```
2. 使用ES6中let关键字定义i值：
```js
var data = [];
for (let i = 0; i < 3; i++) {
    data[i] = function () {
        console.log(i);
    };
}
data[0]();
data[1]();
data[2]();
```

这两种方案都可以达到效果，第一种和我们上面的讲解类似，因为AO中存的就是当前函数上下文的函数参数、函数内部声明的变量等。第二种使用let是比较推荐的方式，let关键字会将for循环的块隐式地声明为块作用域。而for循环头部的let不仅将i绑定到了for循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。而且let使用babel转义后的代码和我们第一种方案基本一致：
```js
var data = [];
var _loop_1 = function (i) {
    data[i] = function () {
        console.log(i);
    };
};
for (var i = 0; i < 3; i++) {
    _loop_1(i);
}
data[0]();
data[1]();
data[2]();
```

至此，我对闭包的理解因为结合了执行上下文，又更加清晰了。接下来我们讲一下闭包的优点和缺点。

## 闭包的优缺点

### 优点
* 缓存变量，被引用的变量长期保持在内存中
- 避免全局变量的污染
+ 模拟私有化成员

### 缺点
* 使用不当，会导致内存泄漏

