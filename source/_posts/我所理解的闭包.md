---
title: 我所理解的闭包
date: 2020-04-29 09:45:35
tags:
    - JavaScript
---
在我的上一篇文章[实现防抖和节流](https://zkat.site/2020/04/26/%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/)中，都是利用闭包缓存变量去实现的，那么今天就来说一下我所理解的闭包是什么。这也是面试中必不可少的部分。本文参考了冴羽大神的JavaScript深入系列的[JavaScript深入之执行上下文](https://github.com/mqyqingfeng/Blog/issues/8)和[JavaScript深入之闭包](https://github.com/mqyqingfeng/Blog/issues/9)，大家可以深入了解下。

## 闭包的概念
MDN中对闭包的定义为：
>函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。

按照这段话的理解，那么每个函数都会形成一个闭包，这和我们平时所理解的闭包不太一样，但是这是理论上的闭包定义，还有一个实践角度上的闭包：
* 即使创建该函数的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
- 在代码中引用了自由变量

>自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。

## 闭包是怎么形成的
我们来看一段MDN上的示例代码：
```
function makeFunc() {
    var name = "Mozilla";
    function displayName() {
        console.log(name);
    }
    return displayName;
}

var myFunc = makeFunc();
myFunc();
```
我们来分析一下这段代码的执行上下文栈和执行上下文的变化情况，不了解代码是怎么执行代码并创建对应执行上下文的，可以去看一下冴羽大神的[JavaScript深入之执行上下文](https://github.com/mqyqingfeng/Blog/issues/8)。执行过程如下：
1. 执行全局代码，创建全局上下文，全局上下文被压入执行上下文栈：
```
ECStack = [
    globalContext
]
```
2. 全局上下文初始化：
```
globalContext = {
    VO: [global],
    Scope: [globalContext.VO],
    this: globalContext.VO
}
```
3. 初始化的同时，创建makeFunc函数，保存作用域链到函数的内部属性[[scope]]:
```
makeFunc.[[scope]] = [
    globalContext.VO
]
```
4. 执行makeFunc函数，创建makeFunc函数上下文，makeFunc函数上下文被压入执行上下文栈：
```
ECStack = [
    globalContext,
    makeFuncContext
]
```
5. makeFunc函数上下文初始化，合并作用域链，同时displayName函数也被创建：
```
makeFuncContext = {
    AO: {
        arguments: {
            length: 0
        },
        name: undefined,
        displayName: reference to function displayName(){}
    },
    Scope: [AO, globalContext],
    this: undefined
}
displayName.[[scope]] = [
    makeFuncContext.AO,
    globalContext.VO
]
```
6. makeFunc函数执行过程中更新AO：
```
makeFuncContext = {
    AO: {
        arguments: {
            length: 0
        },
        name: "Mozilla",
        displayName: reference to function displayName(){}
    },
    Scope: [AO, globalContext.VO],
    this: undefined
}
```
7. makeFunc函数执行完毕，makeFunc函数上下文从执行上下文栈中弹出：
```
ECStack = [
    globalContext
]
```
8. 执行displayName函数，创建displayName函数上下文，displayName函数上下文压入执行上文栈中：
```
ECStack = [
    globalContext,
    displayNameContext
]
```
9. 初始化displayName函数上下文，合并作用域链：
```
displayNameContext = {
    AO: {
        arguments: {
            length: 0
        }
    },
    Scope: [AO, makeFuncContext.AO, globalContext.VO],
    this: undefined
}
```
10. 执行displayName函数，发现函数内部用到变量name，而displayNameContext.AO中并没有name值，沿着作用域链往上找，在makeFuncContext.AO中找到name值，为Mozilla，则打印Mozilla。displayName函数执行完毕，displayName函数上下文从执行上下文中弹出：
```
ECStack = [
    globalContext
]
```

通过上面的解析，我们可以发现，在makeFunc函数上下文从执行上下文栈中弹出后，displayName函数依然存在，并且拥有一个作用域链。所以当makeFuncContext被销毁时，makeFuncContext.AO依然存在于内存中。这就是为什么displayName函数可以读取到makeFuncContext中的值。再结合我们对闭包的实践角度上的定义对比一下，我们发现，displayName函数就是一个典型的闭包。