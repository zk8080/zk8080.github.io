---
title: 浅析深拷贝
date: 2020-04-24 21:47:35
tags:
    - JavaScript
---
JavaScript中深拷贝是一个老生常谈的话题，本文记录下本人所了解的几种实现深拷贝的方式。

## 为什么要使用深拷贝
在JavaScript中，基础类型的值是存在栈空间中，当复制基础类型时，相当于在栈空间中新增一个值相同的变量，但是两个变量互不影响；而复杂类型的值是存在堆空间中，其指针地址则是存在栈空间的，所以当直接复制复杂类型的时候，复制只是栈空间中的指针地址，所以新的变量指向的依然是同一个地址所对应的同一份值。所以当我们复制复杂类型并操作新的变量时，会影响原始变量而出现一系列问题。

## 实现深拷贝
### JSON序列化
根据上面的分析，我们知道基础类型的值是可以直接复制的，那么利用JSON.stringify可以将复杂类型转换成JSON字符串，这个时候再去复制就是一份新的值了，再利用JSON.parse将其转换为JSON对象，就可以达到我们的要求了。代码如下：
```
var obj = {
    arr: [1, 2, 3],
    obj: {key: '对象'},
    str: '123',
    number: 123,
    func: () => {console.log('123')},
    date: new Date(),
    demo: undefined
}

var newObj = JSON.parse(JSON.stringify(obj))

console.log( newObj === obj ) // false
```
这样可以满足我们的需求，但是我们打印`newObj`可以发现，demo和func属性消失了，并且date属性也被转成了字符串。所以这种方法只能深拷贝对象和数组，其他的类型就会出现失真，不过深拷贝数组和对象已经能够满足我们大部分业务需求了，所以开发中如果没有特殊需求的话可以直接使用这种方法。

### 利用for...in和递归
直接上代码：
```
function deepClone(obj) {
    if(typeof obj === 'object' && obj !== null){
        const TypeConstructor = obj.constructor;
        const tmpObj = new TypeConstructor();
        for(let key in obj) {
            tmpObj[key] = deepClone(obj[key])
        }
        return tmpObj;
    }
    return obj;
}

var obj = {
    arr: [1, 2, 3],
    obj: {key: '对象'},
    str: '123',
    number: 123,
    func: () => {console.log('123')},
    date: new Date(),
    demo: undefined
}

var newObj = deepClone(obj)

console.log(newObj === obj) // false

```
我们通过`for...in`来遍历复杂类型，并且配合递归将原始对象中的基本类型一一复制到新的对象中，这样我们就生成了一个新的对象和地址，也是可以满足我们的需求的。而且打印`newObj`会发现`undefined`、`function`、`date`属性值也都是存在的。但是这个函数依然不是完美的，`function`类型依然没有拷贝成功，我使用`lodash`的深拷贝方法试验过，也是无法拷贝`function`，这和HTML5规范定义的[结构化克隆算法](https://developer.mozilla.org/zh-CN/docs/Web/Guide/API/DOM/The_structured_clone_algorithm)有关，大家可以深入了解下。

## 高性能版的深拷贝
上面的递归浅拷贝方法已经可以解决JSON序列化的问题了，但是由于使用递归，对于庞大的数据来说性能上还是有问题的。如何实现高性能版本的深拷贝呢，曾经在掘金上看到yck大佬的文章，[头条面试官：你知道如何实现高性能版本的深拷贝嘛？](https://juejin.im/post/5df7175fe51d45582512962c)，这篇文章里介绍了如何使用`Proxy`对数据进行代理，通过拦截`set`和`get`来生成不可变对象，只对有改变的数据进行拷贝操作从而优化性能。具体的核心思路就是：
* 拦截`set`，所有赋值都在copy（原数据浅拷贝的对象）中进行，这样就不会影响到原对象
- 拦截`get`，通过属性是否修改的逻辑分别从copy或者原数据中取值
+ 最后生成不可变对象的时候遍历原对象，判断属性是否被修改过，也就是判断是否存在copy。如果没有修改过的话，就返回原属性，并且也不再需要对子属性对象遍历，提高了性能。如果修改过的话，就需要把copy赋值到新对象上，并且递归遍历

具体的逻辑和代码大家可以参考yck大佬的文章，在这我就不做多介绍了。