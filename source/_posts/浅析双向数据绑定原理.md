---
title: 浅析双向数据绑定原理
date: 2019-12-12 16:00:56
categories: 前端
tags:
    - React
    - Vue
    - JavaScript
---
之前一直对双向数据绑定一知半解，只知道是通过`Object.definedProperty`进行数据劫持，配合发布-订阅模式进行视图更新。最近看了一些文章，自己也加深了对双向数据绑定的理解，所以来记录一下。

## 双向数据绑定实现思路
我们要实现双向数据绑定可以参考下图思路：
+ 利用Proxy或Object.defineProperty生成的Observer针对对象/对象的属性进行"劫持",在属性发生变化后通知订阅者
- 解析器Compile解析模板中的Directive(指令)，收集指令所依赖的方法和数据,等待数据变化然后进行渲染
* Watcher属于Observer和Compile桥梁,它将接收到的Observer产生的数据变化,并根据Compile提供的指令进行视图渲染,使得数据变化促使视图变化

![](https://raw.githubusercontent.com/zk8080/blog-picture/master/img/162b38ab2d635662.png)

## 数据劫持
数据劫持简单来说就是对对象/对象属性进行拦截，当属性发生改变时，我们可以获取改变进行一些操作。数据劫持目前有两种方法，`Object.definedProperty`和`Proxy`。本文我们主要利用`Object.definedProperty`来实现双向数据绑定。
首先我们利用数据劫持实现一个Observer监听者，监听数据变更，进行依赖收集和派发更新：
```
/**
* @description: 监听者
* @param {type} data: 需要监听的数据
* @return: 
*/
function Observer(data) {
    this.data = data;
    this.walk(data);
} 

Observer.prototype.walk = function (data) {
    // 循环遍历属性，进行拦截操作
    Object.keys(data).forEach(key => defineReactive(data, key, data[key]))
}

function defineReactive(data, key, value) {
    // 对当前监听的值进行递归监听， 如果是复杂类型则继续监听，因为defineProperty只能监听一层属性
    let childObser = observer(value);
    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function () {
            // 在这里进行依赖收集
            return value;
        },
        set: function (newValue) {
            if(value !== newValue){
                value = newValue;
                childObser = observer(value);
                // 在这里派发更新
            }
        }
    })
}
function observer(data) {
    // 如果传进来的数据不存在或者不是复杂类型 则直接返回即可
    if(!data || typeof data !== 'object'){
        return data;
    }
    return new Observer(data);
}

```

## 依赖收集
监听者实现后，我们来实现依赖收集容器，也就是订阅发布中心(Dep)。它主要用于收集订阅者，然后在数据改变时，进行消息发布，执行订阅者的更新方法。
```
/**
* @description: 订阅发布中心
* @param {type} 
* @return: 
*/
let uid = 0;
function Dep() {
    // 设置id,用于区分新Watcher和只改变属性值后新产生的Watcher
    this.id = uid ++;
    // 用来存储订阅者的数组
    this.subs = [];
}

// 静态属性，指向当前的订阅者Watcher
Dep.target = null;

// 收集依赖， 触发订阅者Watcher中的addDep，将自身穿进去
Dep.prototype.depend = function () {
    Dep.target.addDep(this);
}

// 添加订阅者
Dep.prototype.addSub = function (sub) {
    this.subs.push(sub)
}

// 派发更新，触发订阅者Watcher的update方法
Dep.prototype.notify = function () {
    this.subs.forEach(sub => sub.update())
}
```
订阅发布中心很简单，需要注意的是`target`这个静态属性，这个属性指向订阅者Watcher，是Watcher和Dep进行关联的地方，也保证了同一时间只有一个Watcher。实现完发布订阅中心后，我们将监听者中的发布订阅的代码补充以下：
```
function defineReactive(data, key, value) {
    const dep = new Dep();
    // 对当前监听的值进行递归监听， 如果是复杂类型则继续监听，因为defineProperty只能监听一层属性
    let childObser = observer(value);
    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function () {
            // 在这里进行依赖收集
            if(Dep.target){
                dep.depend();
            }
            return value;
        },
        set: function (newValue) {
            if(value !== newValue){
                value = newValue;
                childObser = observer(newValue);
                // 在这里派发更新
                dep.notify();
            }
        }
    })
}
```
接下来我们实现订阅者：

## 订阅者
订阅者Watcher主要是用来将观察的数据，触发监听者Observer中的`get`函数，进行依赖收集，并且将自己传递给订阅发布中心Dep，在Dep派发更新时，触发自己的update函数，更新视图。
```
/**
* @description: 订阅者
* @param {type} vm 被订阅的数据所在实例
* @param {type} key 被订阅的数据属性
* @param {type} callback 数据更新后的回调函数
*/
function Watcher(vm, key, callback ) {
    this.depId = {}; // 存储订阅者id，防止重复订阅
    this.vm = vm;
    this.key = key;
    this.callback = callback;
    this.val = this.get(); // 获取被观察的数据，进行依赖收集
}

// 依赖收集 将自己添加到发布订阅中心中的订阅者数组中
Watcher.prototype.addDep = function (dep) {
    if( !this.depId.hasOwnProperty(dep.id) ){
        dep.addSub(this);
        this.depId[dep.id] = dep;
    }
}
// 用于数据更新时，发布时执行的回调函数
Watcher.prototype.update = function () {
    this.run();
}

Watcher.prototype.run = function () {
    const newVal = this.get();
    if(this.val !== newVal){
        this.val = newVal;
        this.callback(newVal);
    }
}

Watcher.prototype.get = function () {
    // 将Dep的target指向当前订阅者，用于依赖收集
    Dep.target = this;
    const val = this.vm.data[this.key]; //获取订阅的属性值，触发依赖收集
    // 依赖收集完成后 清除当前订阅者
    Dep.target = null;
    return val;
}
```

## 测试
我们已经把双向数据绑定所需要的监听者Observer、订阅发布中心Dep、订阅者Watcher都实现了。还差一个解析器Compile去解析模板中的指令来与订阅者和数据进行关联，进行依赖收集，收到数据更新后，进行视图更新，在这我们就不做具体的实现了，大家可以去看[这篇文章](https://segmentfault.com/a/1190000006599500)，这篇文章对双向数据绑定做了详细的介绍。接下来我们测试以下我们的双向数据绑定：
```
function Vue(data, el, key) {
    this.data = data;
    observer(data);
    el.innerHTML = this.data[key];
    new Watcher(this, key, function (value) {
        el.innerHTML = value;
    })
}

const p = document.getElementById('p');
const input = document.getElementById('input');

const testVue = new Vue({
    name: ''
}, p, 'name');
input.addEventListener('keyup', function (e) {
    testVue.data.name = e.target.value;
})
```
可以看到我们在input输入的时候，p标签内也会做实时更新。到此我们的双向数据绑定也就搞定了，不过具体详细的还是建议大家去读一下大佬们的文章。

## 参考文章
> [剖析Vue原理&实现双向绑定MVVM](https://segmentfault.com/a/1190000006599500)
> [面试官: 实现双向绑定Proxy比defineproperty优劣如何?](https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf#heading-11)
> [通俗易懂了解Vue双向绑定原理及实现](https://www.cnblogs.com/wangjiachen666/p/9883916.html)
